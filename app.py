from flask import Flask, render_template, request, redirect, url_for, flash, session, jsonify, Response
import os
import re
import boto3
from botocore.exceptions import ClientError, NoCredentialsError, EndpointConnectionError
import requests
from flask_bcrypt import Bcrypt
import uuid
from boto3.dynamodb.conditions import Key
from werkzeug.utils import secure_filename
import json
import tempfile
import time
from decimal import Decimal

# ===== VisionLingo =====
import cv2
import numpy as np
import threading
import warnings
from utils.aws_rekognition_infer import AWSRekognitionDetector
from utils.overlay import draw_dots_and_labels
from translate import translate_text

# Suppress OpenCV warnings
os.environ['OPENCV_LOG_LEVEL'] = 'ERROR'
warnings.filterwarnings('ignore')

app = Flask(__name__)
app.secret_key = "dev-secret-change-me"
bcrypt = Bcrypt(app)

# AWS S3 ÂÆ¢Êà∑Á´ØÈÖçÁΩÆ - Áî®‰∫éÂ≠òÂÇ®Èü≥È¢ëÊñá‰ª∂
# ‰Ω†Â∑≤ÁªèÂàõÂª∫‰∫ÜÂêç‰∏∫ "chatbot-audio-url" ÁöÑS3Â≠òÂÇ®Ê°∂
s3_client = boto3.client('s3', region_name=os.environ.get("AWS_REGION", "ap-southeast-1"))
S3_BUCKET_NAME = "chatbot-audio-url"

# DynamoDB setup (uses environment or local credentials)
DYNAMODB_TABLE = os.environ.get("DDB_USERS_TABLE", "Users")
EMAIL_GSI = os.environ.get("DDB_EMAIL_GSI", "email-index")
dynamodb = boto3.resource("dynamodb", region_name=os.environ.get("AWS_REGION", "ap-southeast-1"))
users_table = dynamodb.Table(DYNAMODB_TABLE)
PREFS_TABLE = os.environ.get("DDB_PREFS_TABLE", "users_preferences")
prefs_table = dynamodb.Table(PREFS_TABLE)

# ËÅäÂ§©ËÆ∞ÂΩïDynamoDBË°®ÈÖçÁΩÆ
# ‰Ω†Â∑≤ÁªèÂàõÂª∫‰∫ÜÂêç‰∏∫ "chatbot_logs" ÁöÑDynamoDBË°®
# Ë°®ÁªìÊûÑÔºö
# - users_id (Partition Key): Áî®Êà∑ID
# - chatbot_logs_id (Sort Key): ËÅäÂ§©ËÆ∞ÂΩïÂîØ‰∏ÄID
# - sender: ÂèëÈÄÅËÄÖ ('user' Êàñ 'bot')
# - timestamp: Ê∂àÊÅØÊó∂Èó¥Êà≥
# - message: Ê∂àÊÅØÂÜÖÂÆπ (JSONÊ†ºÂºèÔºåÂåÖÂê´typeÂíåcontent)
CHATBOT_LOGS_TABLE = "chat_logs"
chatbot_logs_table = dynamodb.Table(CHATBOT_LOGS_TABLE)

# Simple in-memory storage for learning check-ins (in production, use database)
learning_checkins = {}  # {user_id: [{'date': 'YYYY-MM-DD', 'timestamp': '...'}]}

# ===== VisionLingo =====
class CameraManager:
    def __init__(self):
        self.current_camera = None
        self.camera_type = None  # 'laptop', 'phone', or 'photo'
        self.phone_ip = "192.168.0.180"  # Updated IP
        self.phone_port = "8080"
        self.camera_lock = threading.Lock()
        self.uploaded_frame = None  # Store uploaded photo frame
        
    def get_phone_url(self):
        return f"http://{self.phone_ip}:{self.phone_port}/video"
    
    def test_camera(self, camera_source, camera_type):
        try:
            test_cap = cv2.VideoCapture(camera_source)
            if test_cap.isOpened():
                ret, frame = test_cap.read()
                test_cap.release()
                if ret and frame is not None:
                    print(f"‚úÖ {camera_type} camera test successful")
                    return True
            test_cap.release()
            print(f"‚ùå {camera_type} camera test failed")
            return False
        except Exception as e:
            print(f"‚ùå {camera_type} camera error: {e}")
            return False
    
    def switch_to_laptop(self):
        with self.camera_lock:
            if self.current_camera:
                self.current_camera.release()
            
            for i in range(3):
                if self.test_camera(i, f"Laptop Camera {i}"):
                    self.current_camera = cv2.VideoCapture(i)
                    self.camera_type = 'laptop'
                    self.uploaded_frame = None
                    print(f"üé• Switched to Laptop Camera {i}")
                    return True
            
            print("‚ùå No laptop camera available")
            return False
    
    def switch_to_phone(self, ip=None, port=None):
        if ip:
            self.phone_ip = ip
        if port:
            self.phone_port = port
        
        phone_url = self.get_phone_url()
        
        with self.camera_lock:
            if self.current_camera:
                self.current_camera.release()
            
            if self.test_camera(phone_url, "Phone Camera"):
                self.current_camera = cv2.VideoCapture(phone_url)
                self.camera_type = 'phone'
                self.uploaded_frame = None
                print(f"üì± Switched to Phone Camera: {phone_url}")
                return True
            else:
                print(f"‚ùå Phone camera not available at {phone_url}")
                self.switch_to_laptop()
                return False
    
    def switch_to_photo(self, photo_frame):
        """Switch to uploaded photo mode"""
        with self.camera_lock:
            if self.current_camera:
                self.current_camera.release()
                self.current_camera = None
            
            self.uploaded_frame = cv2.resize(photo_frame, (640, 480))
            self.camera_type = 'photo'
            print("üñºÔ∏è Switched to uploaded photo")
            return True
    
    def read_frame(self):
        with self.camera_lock:
            if self.camera_type == 'photo' and self.uploaded_frame is not None:
                return True, self.uploaded_frame.copy()
            elif self.current_camera and self.current_camera.isOpened():
                ret, frame = self.current_camera.read()
                if ret:
                    return True, frame
        return False, None
    
    def get_status(self):
        if self.camera_type == 'photo':
            return "üñºÔ∏è Uploaded Photo ‚úÖ"
        elif self.current_camera and self.current_camera.isOpened():
            return f"{self.camera_type.title()} Camera ‚úÖ"
        return "No Camera ‚ùå"

# Initialize camera manager
camera_manager = CameraManager()
camera_manager.switch_to_laptop()

# Selection state
selected_object_idx = None
current_detections = []

# Initialize AWS Rekognition detector
detector = AWSRekognitionDetector()

# Initialize camera manager
camera_manager = CameraManager()
camera_manager.switch_to_laptop()

# Selection state for object detection
selected_object_idx = None
current_detections = []

def gen_frames():
    """Generate frames with object detection using HARDCODED translations"""
    global selected_object_idx, current_detections
    while True:
        success, frame = camera_manager.read_frame()
        if not success or frame is None:
            # Handle error frames
            error_frame = np.zeros((480, 640, 3), dtype=np.uint8)
            cv2.putText(error_frame, "Camera Error - Check Connection", 
                       (120, 220), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 255), 2)
            ret, buffer = cv2.imencode('.jpg', error_frame)
            frame_bytes = buffer.tobytes()
            yield (b'--frame\r\n'
                   b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')
            time.sleep(0.1)
            continue

        try:
            frame = cv2.resize(frame, (640, 480))
            # Get raw detections from AWS Rekognition
            raw_detections = detector.infer(frame)
            
            # ‚úÖ Transform detections with HARDCODED translations
            current_detections = []
            for detection in raw_detections:
                # Extract from AWS detector format
                label = detection.get('label', 'Unknown')
                confidence = detection.get('conf', 0.0)
                
                # Format object names properly
                english_name = label.replace('_', ' ').title()
                
                # ‚úÖ USE HARDCODED TRANSLATIONS from ZH_CN_MAP
                chinese_name = get_hardcoded_translation(english_name)
                
                print(f"üîç Hardcoded Translation: {english_name} ‚Üí {chinese_name}")
                
                # Create detection in expected format
                formatted_detection = {
                    'en': english_name,      # English name  
                    'cn': chinese_name,      # Hardcoded Chinese translation
                    'confidence': confidence # 0-1 format
                }
                current_detections.append(formatted_detection)
            
            # Draw overlay with raw detections
            frame = draw_dots_and_labels(
                frame, raw_detections,
                selected_idx=selected_object_idx,
                show_confidence=False
            )

            # Add camera status overlay
            camera_info = f"{camera_manager.camera_type.upper()} CAM" if camera_manager.camera_type else "NO CAM"
            color = (255, 0, 0) if camera_manager.camera_type == 'laptop' else \
                    (0, 255, 0) if camera_manager.camera_type == 'phone' else \
                    (0, 165, 255) if camera_manager.camera_type == 'photo' else (255, 255, 255)
                    
            cv2.putText(frame, camera_info, (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (255, 255, 255), 2)
            cv2.putText(frame, camera_info, (10, 25), cv2.FONT_HERSHEY_SIMPLEX, 0.6, color, 1)

        except Exception as e:
            print(f"‚ùå Detection error: {e}")
            current_detections = []

        ret, buffer = cv2.imencode('.jpg', frame, [cv2.IMWRITE_JPEG_QUALITY, 90])
        frame_bytes = buffer.tobytes()
        yield (b'--frame\r\n'
               b'Content-Type: image/jpeg\r\n\r\n' + frame_bytes + b'\r\n')
        time.sleep(0.033)  # ~30 FPS


def get_hardcoded_translation(english_text):
    """Get hardcoded translation from ZH_CN_MAP in translate.py"""
    from translate import ZH_CN_MAP
    
    # Try exact match first
    if english_text.lower() in ZH_CN_MAP:
        return ZH_CN_MAP[english_text.lower()]
    
    # Try common AWS Rekognition labels
    aws_to_common = {
        'Adult': 'person',
        'Female': 'female', 
        'Woman': 'female',
        'Man': 'person',
        'Male': 'person',
        'Human': 'person',
        'Face': 'face',
        'Head': 'head',
        'Selfie': 'person',  # Fallback to person
        'Portrait': 'person', # Fallback to person
        'Photography': 'person',
        'Smile': 'smile',
        'Machine': 'laptop',  # Fallback to laptop
        'Electronics': 'laptop',
        'Device': 'laptop'
    }
    
    # Map AWS labels to common dictionary terms
    common_term = aws_to_common.get(english_text, english_text.lower())
    
    # Look up in ZH_CN_MAP
    translation = ZH_CN_MAP.get(common_term, english_text)
    
    return translation


# ===== S3 Âíå DynamoDB ËæÖÂä©ÂáΩÊï∞ =====

def get_username_by_user_id(user_id):
    """
    Ê†πÊçÆÁî®Êà∑IDËé∑ÂèñÁî®Êà∑Âêç
    
    ÂèÇÊï∞:
    - user_id: Áî®Êà∑ID
    
    ËøîÂõû:
    - Áî®Êà∑ÂêçÂ≠óÁ¨¶‰∏≤ÔºåÂ§±Ë¥•ËøîÂõû"Unknown User"
    """
    try:
        response = users_table.get_item(Key={'id': user_id})
        if 'Item' in response:
            return response['Item'].get('username', 'Unknown User')
        else:
            return 'Unknown User'
    except Exception as e:
        print(f"‚ùå Ëé∑ÂèñÁî®Êà∑ÂêçÂ§±Ë¥•: {str(e)}")
        return 'Unknown User'

def get_user_language_preferences(user_id):
    """
    Ê†πÊçÆÁî®Êà∑IDËé∑ÂèñÁî®Êà∑ÂÅèÂ•ΩËÆæÁΩÆ
    
    ÂèÇÊï∞:
    - user_id: Áî®Êà∑ID
    
    ËøîÂõû:
    - Áî®Êà∑ÂÅèÂ•ΩÂ≠óÂÖ∏ÔºåÂ§±Ë¥•ËøîÂõûÈªòËÆ§ËÆæÁΩÆ
    """
    try:
        response = prefs_table.get_item(Key={'users_id': user_id})
        if 'Item' in response:
            prefs = response['Item']
            return {
                'target_language': prefs.get('target_language', 'English'),
                'native_language': prefs.get('native_language', 'Chinese'),
                'level': prefs.get('level', 'Beginner'),
                'age': prefs.get('age', ''),
                'country': prefs.get('country', ''),
                'interest1': prefs.get('interest1', ''),
                'interest2': prefs.get('interest2', '')
            }
        else:
            print(f"‚ö†Ô∏è Áî®Êà∑ {user_id} ÁöÑÂÅèÂ•ΩËÆæÁΩÆÊú™ÊâæÂà∞Ôºå‰ΩøÁî®ÈªòËÆ§ËÆæÁΩÆ")
            return {
                'target_language': 'English',
                'native_language': 'Chinese', 
                'level': 'Beginner'
            }
    except Exception as e:
        print(f"‚ùå Ëé∑ÂèñÁî®Êà∑ÂÅèÂ•ΩÂ§±Ë¥•: {str(e)}")
        return {
            'target_language': 'English',
            'native_language': 'Chinese',
            'level': 'Beginner'
        }

def analyze_pronunciation_accuracy(audio_file, target_language, user_level):
    """
    ÂàÜÊûêËØ≠Èü≥ÂèëÈü≥ÂáÜÁ°ÆÁéá - ‰ΩøÁî®‰∏éfrontend.htmlÁõ∏ÂêåÁöÑwebhookË∞ÉÁî®ÊñπÂºè
    Â∞ÜÈü≥È¢ëËΩ¨Êç¢‰∏∫base64Ê†ºÂºèÂèëÈÄÅJSONÊï∞ÊçÆ
    
    ÂèÇÊï∞:
    - audio_file: Èü≥È¢ëÊñá‰ª∂ÂØπË±°ÊàñÈü≥È¢ëÊñá‰ª∂Ë∑ØÂæÑ
    - target_language: ÁõÆÊ†áËØ≠Ë®Ä
    - user_level: Áî®Êà∑Ê∞¥Âπ≥
    
    ËøîÂõû:
    - ÂàÜÊûêÁªìÊûúÂ≠óÂÖ∏
    """
    try:
        import base64
        
        # ÂáÜÂ§áÂèëÈÄÅÂà∞ÂèëÈü≥ËØÑ‰º∞APIÁöÑÊï∞ÊçÆ
        api_url = "https://n8n.smart87.me/webhook/pronunciation-assessment"
        
        print(f"üé§ ÂºÄÂßãÂ§ÑÁêÜÈü≥È¢ëÊñá‰ª∂...")
        
        # ËØªÂèñÈü≥È¢ëÊñá‰ª∂ÂÜÖÂÆπ
        if hasattr(audio_file, 'read'):
            # Â¶ÇÊûúÊòØÊñá‰ª∂ÂØπË±°ÔºåÈáçÁΩÆÊåáÈíàÂà∞ÂºÄÂßãÂπ∂ËØªÂèñÂÜÖÂÆπ
            audio_file.seek(0)
            audio_content = audio_file.read()
            filename = getattr(audio_file, 'filename', 'audio.webm')
            print(f"üìÅ Â§ÑÁêÜÊñá‰ª∂ÂØπË±°: {filename}")
        else:
            # Â¶ÇÊûúÊòØÊñá‰ª∂Ë∑ØÂæÑÔºåËØªÂèñÊñá‰ª∂
            with open(audio_file, 'rb') as f:
                audio_content = f.read()
            filename = audio_file
            print(f"üìÅ Â§ÑÁêÜÊñá‰ª∂Ë∑ØÂæÑ: {filename}")
        
        print(f"üìä Èü≥È¢ëÊñá‰ª∂Â§ßÂ∞è: {len(audio_content)} bytes")
        
        # ËΩ¨Êç¢Èü≥È¢ë‰∏∫base64Ôºà‰ΩøÁî®‰∏éfrontend.htmlÁõ∏ÂêåÁöÑÊñπÊ≥ïÔºâ
        print(f"üîÑ ËΩ¨Êç¢Èü≥È¢ë‰∏∫base64...")
        base64_audio = base64.b64encode(audio_content).decode('utf-8')
        print(f"üìù Base64ÁºñÁ†ÅÈïøÂ∫¶: {len(base64_audio)}")
        
        # ÂáÜÂ§áJSONË¥üËΩΩÔºà‰∏éfrontend.htmlÁõ∏ÂêåÁöÑÊ†ºÂºèÔºâ
        payload = {
            'audio': base64_audio,
            'referenceText': "ÂêÑ‰∏™ÂõΩÂÆ∂ÊúâÂêÑ‰∏™ÂõΩÂÆ∂ÁöÑÂõΩÊ≠å",  # ‰ΩøÁî®Áõ∏ÂêåÁöÑÂèÇËÄÉÊñáÊú¨
            'language': "zh-CN"  # ‰ΩøÁî®Áõ∏ÂêåÁöÑËØ≠Ë®ÄËÆæÁΩÆ
        }
        
        print(f"üì§ ÂèëÈÄÅJSONÊï∞ÊçÆÂà∞webhook...")
        print(f"üåê ÁõÆÊ†áURL: {api_url}")
        
        # ËÆ∞ÂΩïAPIËØ∑Ê±ÇÂºÄÂßãÊó∂Èó¥
        api_start_time = time.time()
        
        # ÂèëÈÄÅPOSTËØ∑Ê±ÇÔºà‰∏éfrontend.htmlÁõ∏ÂêåÁöÑÊñπÂºèÔºâ
        response = requests.post(
            api_url,
            json=payload,  # ‰ΩøÁî®JSONËÄå‰∏çÊòØform-data
            timeout=30,
            headers={
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }
        )
        
        # ËÆ°ÁÆóAPIÂìçÂ∫îÊó∂Èó¥
        api_response_time = round(time.time() - api_start_time, 2)
        
        print(f"üì• ÂìçÂ∫îÁä∂ÊÄÅ: {response.status_code}")
        print(f"‚è±Ô∏è APIÂìçÂ∫îÊó∂Èó¥: {api_response_time} Áßí")
        
        # Ê£ÄÊü•ÂìçÂ∫îÁä∂ÊÄÅ
        response.raise_for_status()
        
        # Ëß£ÊûêAPIÂìçÂ∫î - Â§ÑÁêÜÊï∞ÁªÑÊ†ºÂºèÁöÑÂìçÂ∫îÔºàÂèÇËÄÉfrontend.htmlÁöÑÈÄªËæëÔºâ
        api_result = response.json()
        print(f"‚úÖ Êî∂Âà∞APIÂìçÂ∫î: {type(api_result)}")
        
        # Ê∑ªÂä†ËØ¶ÁªÜÁöÑAPIÂìçÂ∫îË∞ÉËØï
        print(f"üîç ÂÆåÊï¥APIÂìçÂ∫îÁªìÊûÑ:")
        print(json.dumps(api_result, indent=2, ensure_ascii=False))
        
        # ‰ΩøÁî®‰∏éfrontend.htmlÁõ∏ÂêåÁöÑÈÄªËæëÂ§ÑÁêÜÊï∞ÁªÑÂìçÂ∫î
        if not isinstance(api_result, list):
            print("‚ùå APIÂìçÂ∫î‰∏çÊòØÊï∞ÁªÑÊ†ºÂºè")
            return {
                'error': True,
                'message': 'APIÂìçÂ∫îÊ†ºÂºèÈîôËØØÔºåÊúüÂæÖÊï∞ÁªÑÊ†ºÂºè',
                'transcript': '',
                'target_language': target_language,
                'user_level': user_level,
                'analysis_timestamp': int(time.time()),
                'api_response': api_result
            }
        
        # Êü•ÊâæÂåÖÂê´ËØ≠Èü≥ËØÑ‰º∞Êï∞ÊçÆÁöÑÂØπË±°ÔºàÊúâ'success'Âíå'data'Â≠óÊÆµÔºâ
        speech_assessment_response = None
        for item in api_result:
            if (isinstance(item, dict) and 
                'success' in item and 
                'data' in item and 
                isinstance(item.get('data'), dict)):
                speech_assessment_response = item
                break
        
        # Êü•ÊâæÂåÖÂê´ÊñáÊú¨ÂìçÂ∫îÁöÑÂØπË±°ÔºàÊúâ'text'Â≠óÊÆµÔºâ
        text_response = None
        for item in api_result:
            if isinstance(item, dict) and 'text' in item:
                text_response = item
                break
        
        print(f"üîç ÊâæÂà∞ËØ≠Èü≥ËØÑ‰º∞ÂìçÂ∫î: {speech_assessment_response is not None}")
        print(f"üîç ÊâæÂà∞ÊñáÊú¨ÂìçÂ∫î: {text_response is not None}")
        
        if not speech_assessment_response:
            print("‚ùå Âú®APIÂìçÂ∫î‰∏≠Êú™ÊâæÂà∞ËØ≠Èü≥ËØÑ‰º∞Êï∞ÊçÆ")
            return {
                'error': True,
                'message': 'Êú™ÊâæÂà∞ËØ≠Èü≥ËØÑ‰º∞Êï∞ÊçÆ',
                'transcript': '',
                'target_language': target_language,
                'user_level': user_level,
                'analysis_timestamp': int(time.time()),
                'api_response': api_result
            }
        
        # Ê£ÄÊü•ÊòØÂê¶ÊàêÂäü
        success = speech_assessment_response.get('success', True)
        print(f"üîç APIÊàêÂäüÁä∂ÊÄÅ: {success}")
        
        if not success:
            print("‚ùå APIÂìçÂ∫îÊòæÁ§∫Â§ÑÁêÜÂ§±Ë¥•")
            return {
                'error': True,
                'message': 'APIÂìçÂ∫îÊòæÁ§∫Â§ÑÁêÜÂ§±Ë¥•',
                'transcript': '',
                'target_language': target_language,
                'user_level': user_level,
                'analysis_timestamp': int(time.time()),
                'api_response': api_result
            }
        
        # ÊèêÂèñÂÆûÈôÖÊï∞ÊçÆÂØπË±°
        actual_data = speech_assessment_response.get('data', {})
        
        print(f"üîç ÊèêÂèñÂà∞ÁöÑactual_dataÁ±ªÂûã: {type(actual_data)}")
        print(f"üîç actual_dataÂÜÖÂÆπ: {actual_data}")
        
        # ÊèêÂèñËΩ¨ÂΩïÊñáÊú¨
        transcript = ''
        reference_text = ''
        
        if isinstance(actual_data, dict):
            print(f"üîç actual_dataÁöÑÊâÄÊúâÂ≠óÊÆµ: {list(actual_data.keys())}")
            
            # Áõ¥Êé•ÊèêÂèñrecognizedTextÂíåreferenceText
            transcript = actual_data.get('recognizedText', '').strip()
            reference_text = actual_data.get('referenceText', '').strip()
            
            print(f"‚úÖ ËØÜÂà´ÊñáÊú¨ (recognizedText): '{transcript}'")
            print(f"‚úÖ ÂèÇËÄÉÊñáÊú¨ (referenceText): '{reference_text}'")
            
        else:
            print(f"‚ùå actual_data‰∏çÊòØÂ≠óÂÖ∏Á±ªÂûã: {type(actual_data)}")
        
        # Â¶ÇÊûú‰ªçÁÑ∂Ê≤°ÊúâÊâæÂà∞ËΩ¨ÂΩïÊñáÊú¨
        if not transcript:
            print("‚ùå Êó†Ê≥ï‰ªéAPIÂìçÂ∫î‰∏≠ÊâæÂà∞ËΩ¨ÂΩïÊñáÊú¨")
            print(f"üîç ÂÆåÊï¥ÂìçÂ∫îÁªìÊûÑË∞ÉËØï:")
            print(f"  - api_resultÁ±ªÂûã: {type(api_result)}")
            print(f"  - speech_assessment_responseÁ±ªÂûã: {type(speech_assessment_response)}")
            print(f"  - actual_dataÁ±ªÂûã: {type(actual_data)}")
            if isinstance(actual_data, dict):
                print(f"  - actual_dataÂ≠óÊÆµ: {list(actual_data.keys())}")
            
            # ‰ΩøÁî®ÊòéÁ°ÆÁöÑÈîôËØØ‰ø°ÊÅØ
            transcript = f"[ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•] APIÂìçÂ∫îËß£ÊûêÈîôËØØ"
        
        # ÊèêÂèñÁªºÂêàËØÑÂàÜ
        overall_scores = actual_data.get('overall', {}) if isinstance(actual_data, dict) else {}
        pronunciation_score = overall_scores.get('pronunciationScore', 0) if isinstance(overall_scores, dict) else 0
        accuracy_score = overall_scores.get('accuracyScore', 0) if isinstance(overall_scores, dict) else 0
        fluency_score = overall_scores.get('fluencyScore', 0) if isinstance(overall_scores, dict) else 0
        completeness_score = overall_scores.get('completenessScore', 0) if isinstance(overall_scores, dict) else 0
        prosody_score = overall_scores.get('prosodyScore', 0) if isinstance(overall_scores, dict) else 0
        
        # ÊèêÂèñËØçÊ±áËØ¶ÊÉÖ
        words_data = actual_data.get('words', []) if isinstance(actual_data, dict) else []
        
        print(f"üéØ ËØÜÂà´ÊñáÊú¨: {transcript}")
        print(f"üéØ ÂèÇËÄÉÊñáÊú¨: {reference_text}")
        print(f"üìä ÂèëÈü≥ÂæóÂàÜ: {pronunciation_score}")
        print(f"üìä ÂáÜÁ°ÆÂ∫¶: {accuracy_score}")
        print(f"üìä ÊµÅÂà©Â∫¶: {fluency_score}")
        print(f"ÔøΩ ÂÆåÊï¥Â∫¶: {completeness_score}")
        print(f"üìä ÈüµÂæãÂæóÂàÜ: {prosody_score}")
        print(f"ÔøΩüìù ËØçÊ±áÊï∞Èáè: {len(words_data) if isinstance(words_data, list) else 0}")
        
        print(f"üìù ËØçÊ±áÊï∞Èáè: {len(words_data) if isinstance(words_data, list) else 0}")
        
        # Â§ÑÁêÜÊñáÊú¨ÂìçÂ∫îÔºàAIÂèçÈ¶àÔºâ
        ai_feedback_text = ''
        if text_response and isinstance(text_response, dict) and 'text' in text_response:
            ai_feedback_text = text_response.get('text', '')
            print(f"ü§ñ AIÂèçÈ¶à: {ai_feedback_text[:100]}..." if len(ai_feedback_text) > 100 else f"ü§ñ AIÂèçÈ¶à: {ai_feedback_text}")
        
        # ÊûÑÂª∫ËøîÂõûÁªìÊûúÔºå‰øùÊåÅ‰∏éÂéüÊúâÊ†ºÂºèÂÖºÂÆπ
        analysis_result = {
            'transcript': transcript,
            'reference_text': reference_text,
            'target_language': target_language,
            'user_level': user_level,
            'pronunciation_score': pronunciation_score,
            'accuracy_score': accuracy_score,
            'fluency_score': fluency_score,
            'completeness_score': completeness_score,  # Ê∑ªÂä†ÂÆåÊï¥Â∫¶ËØÑÂàÜ
            'prosody_score': prosody_score,  # Ê∑ªÂä†ÈüµÂæãËØÑÂàÜ
            'api_response_time': api_response_time,  # Ê∑ªÂä†APIÂìçÂ∫îÊó∂Èó¥
            'ai_feedback': ai_feedback_text,  # Ê∑ªÂä†AIÂèçÈ¶à
            'feedback': {
                'overall': ai_feedback_text if ai_feedback_text else f"ËØÜÂà´ÊñáÊú¨: {transcript}",
                'strengths': [],
                'improvements': [],
                'suggestions': []
            },
            'analysis_timestamp': int(time.time()),
            'api_response': api_result,  # ‰øùÂ≠òÂÆåÊï¥ÁöÑAPIÂìçÂ∫îÁî®‰∫éË∞ÉËØï
            'words_analysis': words_data  # ‰øùÂ≠òËØçÊ±áÂàÜÊûêÊï∞ÊçÆ
        }
        
        return analysis_result
        
    except requests.exceptions.Timeout:
        # Â§ÑÁêÜË∂ÖÊó∂ÈîôËØØ
        return {
            'error': True,
            'message': 'ÂèëÈü≥ËØÑ‰º∞APIËØ∑Ê±ÇË∂ÖÊó∂ÔºåËØ∑Á®çÂêéÈáçËØï',
            'transcript': '',
            'target_language': target_language,
            'user_level': user_level,
            'pronunciation_score': 0,
            'feedback': {
                'overall': 'Á≥ªÁªüÊöÇÊó∂Êó†Ê≥ïÂàÜÊûêÔºåËØ∑Á®çÂêéÈáçËØï',
                'strengths': [],
                'improvements': [],
                'suggestions': ['ËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂêéÈáçËØï']
            },
            'analysis_timestamp': int(time.time())
        }
        
    except requests.exceptions.RequestException as e:
        # Â§ÑÁêÜÂÖ∂‰ªñÁΩëÁªúËØ∑Ê±ÇÈîôËØØ
        return {
            'error': True,
            'message': f'ÂèëÈü≥ËØÑ‰º∞APIËØ∑Ê±ÇÂ§±Ë¥•: {str(e)}',
            'transcript': '',
            'target_language': target_language,
            'user_level': user_level,
            'pronunciation_score': 0,
            'feedback': {
                'overall': 'Á≥ªÁªüÊöÇÊó∂Êó†Ê≥ïÂàÜÊûêÔºåËØ∑Á®çÂêéÈáçËØï',
                'strengths': [],
                'improvements': [],
                'suggestions': ['ËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÂêéÈáçËØï']
            },
            'analysis_timestamp': int(time.time())
        }
        
    except json.JSONDecodeError:
        # Â§ÑÁêÜJSONËß£ÊûêÈîôËØØ
        return {
            'error': True,
            'message': 'ÂèëÈü≥ËØÑ‰º∞APIËøîÂõûÊï∞ÊçÆÊ†ºÂºèÈîôËØØ',
            'transcript': '',
            'target_language': target_language,
            'user_level': user_level,
            'pronunciation_score': 0,
            'feedback': {
                'overall': 'Á≥ªÁªüÊöÇÊó∂Êó†Ê≥ïÂàÜÊûêÔºåËØ∑Á®çÂêéÈáçËØï',
                'strengths': [],
                'improvements': [],
                'suggestions': ['ËØ∑ËÅîÁ≥ªÁ≥ªÁªüÁÆ°ÁêÜÂëò']
            },
            'analysis_timestamp': int(time.time())
        }
        
    except Exception as e:
        # Â§ÑÁêÜÂÖ∂‰ªñÊú™Áü•ÈîôËØØ
        return {
            'error': True,
            'message': f'ÂèëÈü≥ËØÑ‰º∞ËøáÁ®ã‰∏≠Âá∫Áé∞Êú™Áü•ÈîôËØØ: {str(e)}',
            'transcript': '',
            'target_language': target_language,
            'user_level': user_level,
            'pronunciation_score': 0,
            'feedback': {
                'overall': 'Á≥ªÁªüÊöÇÊó∂Êó†Ê≥ïÂàÜÊûêÔºåËØ∑Á®çÂêéÈáçËØï',
                'strengths': [],
                'improvements': [],
                'suggestions': ['ËØ∑ËÅîÁ≥ªÁ≥ªÁªüÁÆ°ÁêÜÂëò']
            },
            'analysis_timestamp': int(time.time())
        }

def upload_audio_to_s3(audio_file, user_id, is_bot_audio=False):
    """
    ‰∏ä‰º†Èü≥È¢ëÊñá‰ª∂Âà∞S3Â≠òÂÇ®Ê°∂
    
    ÂèÇÊï∞:
    - audio_file: ‰∏ä‰º†ÁöÑÊñá‰ª∂ÂØπË±°
    - user_id: Áî®Êà∑ID
    - is_bot_audio: ÊòØÂê¶ÊòØÊú∫Âô®‰∫∫Èü≥È¢ë
    
    ËøîÂõû:
    - S3Êñá‰ª∂ÁöÑÂÆåÊï¥URLÔºåÂ§±Ë¥•ËøîÂõûNone
    """
    try:
        timestamp = str(int(time.time() * 1000))
        
        # Ëé∑ÂèñÊñá‰ª∂ÂêçÔºåÊîØÊåÅ‰∏çÂêåÁ±ªÂûãÁöÑÊñá‰ª∂ÂØπË±°
        if hasattr(audio_file, 'filename') and audio_file.filename:
            original_filename = secure_filename(audio_file.filename)
        elif hasattr(audio_file, 'name') and audio_file.name:
            # Â¶ÇÊûúÊòØÊôÆÈÄöÊñá‰ª∂ÂØπË±°Ôºå‰ªéË∑ØÂæÑ‰∏≠ÊèêÂèñÊñá‰ª∂Âêç
            original_filename = secure_filename(os.path.basename(audio_file.name))
        else:
            original_filename = "recording.webm"
        
        unique_filename = f"{timestamp}_{original_filename}"
        
        # Ê†πÊçÆÊñá‰ª∂Êâ©Â±ïÂêçÂà§Êñ≠Èü≥È¢ëÊ†ºÂºèÂíåContent-Type
        file_extension = original_filename.lower().split('.')[-1] if '.' in original_filename else 'webm'
        
        content_type_map = {
            'wav': 'audio/wav',
            'webm': 'audio/webm', 
            'mp3': 'audio/mpeg',
            'ogg': 'audio/ogg',
            'flac': 'audio/flac',
            'm4a': 'audio/mp4'
        }
        
        content_type = content_type_map.get(file_extension, 'audio/wav')  # ÈªòËÆ§‰∏∫WAV
        
        # Ê†πÊçÆÈü≥È¢ëÁ±ªÂûãÈÄâÊã©Â≠òÂÇ®Ë∑ØÂæÑ
        if is_bot_audio:
            s3_key = f"audio/bot/{user_id}/{unique_filename}"
        else:
            s3_key = f"audio/user/{user_id}/{unique_filename}"
        
        print(f"üì§ ÂºÄÂßã‰∏ä‰º†Èü≥È¢ëÂà∞S3:")
        print(f"   Â≠òÂÇ®Ê°∂: {S3_BUCKET_NAME}")
        print(f"   Êñá‰ª∂Ë∑ØÂæÑ: {s3_key}")
        print(f"   Content-Type: {content_type}")
        
        # ‰∏ä‰º†Êñá‰ª∂Âà∞S3
        s3_client.upload_fileobj(
            audio_file,
            S3_BUCKET_NAME,
            s3_key,
            ExtraArgs={
                'ContentType': content_type,  # ‰ΩøÁî®Ê£ÄÊµãÂà∞ÁöÑContent-Type
                'CacheControl': 'max-age=31536000'
            }
        )
        
        # ÁîüÊàêS3Êñá‰ª∂URL
        s3_url = f"https://{S3_BUCKET_NAME}.s3.{os.environ.get('AWS_REGION', 'ap-southeast-1')}.amazonaws.com/{s3_key}"
        
        print(f"‚úÖ Èü≥È¢ë‰∏ä‰º†ÊàêÂäü ({file_extension.upper()}): {s3_url}")
        print(f"üéµ Content-Type: {content_type}")
        return s3_url
        
    except Exception as e:
        print(f"‚ùå S3‰∏ä‰º†Â§±Ë¥•ËØ¶ÁªÜÈîôËØØ: {type(e).__name__}: {str(e)}")
        import traceback
        print(f"üîç ÈîôËØØÂ†ÜÊ†à:")
        traceback.print_exc()
        return None

def save_chat_message_to_dynamodb(users_id, sender, message_content, message_type="text", audio_url=None, pronunciation_assessment=None):
    """
    ‰øùÂ≠òËÅäÂ§©Ê∂àÊÅØÂà∞DynamoDB
    
    ÂèÇÊï∞:
    - users_id: Áî®Êà∑ID (Partition Key)
    - sender: ÂèëÈÄÅËÄÖÂêçÁß∞ (Áî®Êà∑ÂêçÊàñ 'system')
    - message_content: Ê∂àÊÅØÊñáÊú¨ÂÜÖÂÆπ
    - message_type: Ê∂àÊÅØÁ±ªÂûã ('text' Êàñ 'audio')
    - audio_url: Èü≥È¢ëÊñá‰ª∂ÁöÑS3 URL (ÂèØÈÄâ)
    - pronunciation_assessment: ÂèëÈü≥ËØÑ‰º∞ÁªìÊûú (ÂèØÈÄâ)
    
    ËøîÂõû:
    - ‰øùÂ≠òÊàêÂäüËøîÂõûchatbot_logs_idÔºåÂ§±Ë¥•ËøîÂõûNone
    """
    try:
        # ÁîüÊàêÂîØ‰∏ÄÁöÑËÅäÂ§©ËÆ∞ÂΩïIDÂíåÊó∂Èó¥Êà≥
        chatbot_logs_id = str(uuid.uuid4())
        timestamp = int(time.time())
        
        # ÊûÑÂª∫Ê∂àÊÅØJSONÊ†ºÂºè
        message_json = {
            "type": message_type,
            "content": message_content
        }
        
        # Â¶ÇÊûúÊúâÈü≥È¢ëURLÔºåÊ∑ªÂä†Âà∞Ê∂àÊÅØ‰∏≠
        if audio_url:
            message_json["audio_url"] = audio_url
            
        # Â¶ÇÊûúÊúâÂèëÈü≥ËØÑ‰º∞ÁªìÊûúÔºåÊ∑ªÂä†Âà∞Ê∂àÊÅØ‰∏≠
        if pronunciation_assessment:
            message_json["pronunciation_assessment"] = pronunciation_assessment
        
        # ÊûÑÂª∫Ë¶Å‰øùÂ≠òÁöÑÊï∞ÊçÆÈ°π
        item = {
            'users_id': users_id,              # Partition Key
            'chatbot_logs_id': chatbot_logs_id, # Sort Key
            'sender': sender,
            'timestamp': timestamp,
            'message': message_json  # Áõ¥Êé•Â≠òÂÇ®‰∏∫ÊôÆÈÄö JSON ÂØπË±°
        }
        
        # ‰øùÂ≠òÂà∞DynamoDB (‰ΩøÁî® Table resource Á°Æ‰øùÊ≠£Á°ÆÁöÑÊï∞ÊçÆÁ±ªÂûãËΩ¨Êç¢)
        response = chatbot_logs_table.put_item(Item=item)
        
        print(f"‚úÖ ËÅäÂ§©ËÆ∞ÂΩï‰øùÂ≠òÊàêÂäü: Áî®Êà∑{users_id}, ÂèëÈÄÅËÄÖ{sender}, Á±ªÂûã{message_type}")
        print(f"üìä ‰øùÂ≠òÁöÑ message Êï∞ÊçÆ: {message_json}")  # ÊòæÁ§∫ÂÆûÈôÖ‰øùÂ≠òÁöÑ JSON
        print(f"üîë ÁîüÊàêÁöÑ chatbot_logs_id: {chatbot_logs_id}")  # ÊòæÁ§∫ÁîüÊàêÁöÑID
        return chatbot_logs_id
        
    except Exception as e:
        print(f"‚ùå DynamoDB‰øùÂ≠òÂ§±Ë¥•: {str(e)}")
        return None

def get_chat_history_from_dynamodb(users_id, limit=20, last_chatbot_logs_id=None):
    """
    ‰ªéDynamoDBËé∑ÂèñÁî®Êà∑ÁöÑËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩï
    
    ÂèÇÊï∞:
    - users_id: Áî®Êà∑ID
    - limit: ËøîÂõûÁöÑÊ∂àÊÅØÊï∞ÈáèÈôêÂà∂
    - last_chatbot_logs_id: ‰∏äÊ¨°Êü•ËØ¢ÁöÑÊúÄÂêé‰∏Ä‰∏™ËÆ∞ÂΩïIDÔºåÁî®‰∫éÂàÜÈ°µ
    
    ËøîÂõû:
    - ËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩïÂàóË°®
    """
    try:
        # ÊûÑÂª∫Êü•ËØ¢ÂèÇÊï∞
        query_params = {
            'KeyConditionExpression': Key('users_id').eq(users_id),
            'Limit': limit
        }
        
        # Â¶ÇÊûúÊèê‰æõ‰∫Ülast_chatbot_logs_idÔºåÂàô‰ªéËØ•‰ΩçÁΩÆÂºÄÂßãÊü•ËØ¢
        if last_chatbot_logs_id:
            query_params['ExclusiveStartKey'] = {
                'users_id': users_id,
                'chatbot_logs_id': last_chatbot_logs_id
            }
        
        # ÊâßË°åÊü•ËØ¢
        response = chatbot_logs_table.query(**query_params)
        
        # ËΩ¨Êç¢Ê∂àÊÅØÊ†ºÂºè
        messages = []
        for item in response['Items']:
            # Áõ¥Êé•‰ΩøÁî®JSONÂØπË±°ÔºåÊó†ÈúÄËß£ÊûêÂ≠óÁ¨¶‰∏≤
            message_data = item['message']  # Áõ¥Êé•Ëé∑ÂèñJSONÂØπË±°
            
            formatted_message = {
                'chatbot_logs_id': item['chatbot_logs_id'],
                'sender': item['sender'],
                'message_type': message_data.get('type', 'text'),
                'message_content': message_data.get('content', ''),
                'timestamp': item['timestamp']
            }
            
            # Â¶ÇÊûúÊúâÈü≥È¢ëURLÔºåÊ∑ªÂä†Âà∞ÂìçÂ∫î‰∏≠
            if 'audio_url' in message_data:
                formatted_message['audio_url'] = message_data['audio_url']
            
            messages.append(formatted_message)
        
        # ÊåâÊó∂Èó¥Êà≥ÂíåÂèëÈÄÅËÄÖÊéíÂ∫èÔºöÁ°Æ‰øùÁî®Êà∑Ê∂àÊÅØÂú®ÂâçÔºåÁ≥ªÁªüÂõûÂ§çÂú®Âêé
        # È¶ñÂÖàÊåâÊó∂Èó¥Êà≥ÊéíÂ∫èÔºåÁÑ∂ÂêéÂú®Áõ∏ÂêåÊó∂Èó¥ÊÆµÂÜÖÔºåÁî®Êà∑Ê∂àÊÅØ‰ºòÂÖà‰∫éÁ≥ªÁªüÊ∂àÊÅØ
        messages.sort(key=lambda x: (x['timestamp'], x['sender'] == 'system'))
        
        print(f"‚úÖ Ëé∑ÂèñËÅäÂ§©ÂéÜÂè≤ÊàêÂäü: Áî®Êà∑{users_id}, ÂÖ±{len(messages)}Êù°Ê∂àÊÅØ")
        return {
            'messages': messages,
            'has_more': 'LastEvaluatedKey' in response,
            'last_chatbot_logs_id': response.get('LastEvaluatedKey', {}).get('chatbot_logs_id')
        }
        
    except Exception as e:
        print(f"‚ùå Ëé∑ÂèñËÅäÂ§©ÂéÜÂè≤Â§±Ë¥•: {str(e)}")
        return {'messages': [], 'has_more': False, 'last_chatbot_logs_id': None}
    
def translate_text(text, target_language='Chinese', source_language='English'):
    """Simple translation fallback function"""
    translations = {
        'Person': '‰∫∫', 'people': '‰∫∫‰ª¨', 'man': 'Áî∑‰∫∫', 'woman': 'Â•≥‰∫∫',
        'Cup': 'ÊùØÂ≠ê', 'mug': 'È©¨ÂÖãÊùØ', 'glass': 'ÁéªÁíÉÊùØ',
        'Bottle': 'Áì∂Â≠ê', 'water bottle': 'Ê∞¥Áì∂',
        'Chair': 'Ê§ÖÂ≠ê', 'seat': 'Â∫ß‰Ωç',
        'Book': '‰π¶', 'notebook': 'Á¨îËÆ∞Êú¨',
        'Cell Phone': 'ÊâãÊú∫', 'Mobile Phone': 'ÊâãÊú∫', 'smartphone': 'Êô∫ËÉΩÊâãÊú∫',
        'Laptop': 'Á¨îËÆ∞Êú¨ÁîµËÑë', 'Computer': 'ÁîµËÑë',
        'Car': 'Ê±ΩËΩ¶', 'vehicle': 'ËΩ¶ËæÜ',
        'Clock': 'ÈíüË°®', 'watch': 'ÊâãË°®',
        'Dog': 'Áãó', 'puppy': 'Â∞èÁãó',
        'Cat': 'Áå´', 'kitten': 'Â∞èÁå´',
        'Table': 'Ê°åÂ≠ê', 'desk': '‰π¶Ê°å',
        'Bed': 'Â∫ä',
        'Door': 'Èó®',
        'Window': 'Á™óÊà∑',
        'Mouse': 'Èº†Ê†á',
        'Keyboard': 'ÈîÆÁõò',
        'Monitor': 'ÊòæÁ§∫Âô®',
        'Bag': 'ÂåÖ',
        'Shoe': 'Èûã',
        'Glasses': 'ÁúºÈïú'
    }
    return translations.get(text, text)  # Return original if no translation found

@app.route("/")
def home():
    return render_template("index.html")

@app.route("/login", methods=["POST"])
def login():
    email = request.form.get("email", "").strip()
    password = request.form.get("password", "")
    if not email or not password:
        flash("Email and password are required.", "danger")
        return redirect(url_for("register_page", tab="login"))
    try:
        resp = users_table.query(IndexName=EMAIL_GSI, KeyConditionExpression=Key("email").eq(email))
        items = resp.get("Items", [])
        user = items[0] if items else None
        if not user:
            flash("Invalid email or password.", "danger")
            return redirect(url_for("register_page", tab="login"))
        if bcrypt.check_password_hash(user.get("password_hash", ""), password):
            session["user_id"] = user.get("id")
            session["username"] = user.get("username")
            session["email"] = user.get("email")
        else:
            flash("Invalid email or password.", "danger")
            return redirect(url_for("register_page", tab="login"))
    except ClientError as e:
        error_code = e.response['Error']['Code']
        error_message = e.response['Error']['Message']
        print(f"DynamoDB ClientError - Code: {error_code}, Message: {error_message}")
        flash(f"Login error: {error_code} - {error_message}", "danger")
        return redirect(url_for("register_page", tab="login"))
    except NoCredentialsError:
        print("AWS credentials not found")
        flash("Login error: AWS credentials not configured", "danger")
        return redirect(url_for("register_page", tab="login"))
    except EndpointConnectionError:
        print("Cannot connect to DynamoDB endpoint")
        flash("Login error: Cannot connect to database", "danger")
        return redirect(url_for("register_page", tab="login"))
    except Exception as e:
        print(f"Unexpected login error: {str(e)}")
        flash(f"Login error: {str(e)}", "danger")
        return redirect(url_for("register_page", tab="login"))
    
    # If preferences already exist, skip onboarding
    try:
        pref = prefs_table.get_item(Key={"users_id": session.get("user_id")})
        if pref.get("Item"):
            return redirect(url_for("dashboard"))
    except Exception:
        pass
    return redirect(url_for("onboarding"))

@app.route("/register", methods=["POST"])
def register():
    username = request.form.get("username", "").strip()
    email = request.form.get("email", "").strip()
    password = request.form.get("password", "")
    confirm_password = request.form.get("confirm_password", "")

    # Basic validations
    if not username or not email or not password:
        flash("Please fill in all required fields.", "danger")
        return redirect(url_for("register_page"))
    if "@" not in email:
        flash("Email must contain @.", "danger")
        return redirect(url_for("register_page"))
    if len(username) > 50 or re.search(r"\s", username):
        flash("Username must be <= 50 chars with no spaces.", "danger")
        return redirect(url_for("register_page"))
    if password != confirm_password:
        flash("Passwords do not match.", "danger")
        return redirect(url_for("register_page"))

    # Ensure email not already registered (via GSI)
    try:
        existing = users_table.query(IndexName=EMAIL_GSI, KeyConditionExpression=Key("email").eq(email))
        if existing.get("Count", 0) > 0:
            flash("Email already registered.", "danger")
            return redirect(url_for("register_page"))

        # Create user with generated id (PK)
        password_hash = bcrypt.generate_password_hash(password).decode("utf-8")
        users_table.put_item(
            Item={
                "id": str(uuid.uuid4()),
                "username": username,
                "email": email,
                "password_hash": password_hash,
            },
            ConditionExpression="attribute_not_exists(id)",
        )
        flash("Congratulations, you've registered successfully.", "success")
    except ClientError as e:
        code = e.response.get("Error", {}).get("Code", "ClientError")
        msg = e.response.get("Error", {}).get("Message", "")
        if code == "ConditionalCheckFailedException":
            flash("Username already exists.", "danger")
        else:
            flash(f"Registration error: {code} {msg}", "danger")
    except NoCredentialsError:
        flash("Registration error: No AWS credentials found. Configure AWS credentials.", "danger")
    except EndpointConnectionError as e:
        flash("Registration error: Cannot reach DynamoDB endpoint/region. Check AWS_REGION and network.", "danger")
    return redirect(url_for("register_page"))

@app.route("/service-details")
def service_details():
    return render_template("service-details.html")

@app.route("/register", methods=["GET"])
def register_page():
    return render_template("register.html")

@app.route("/onboarding")
def onboarding():
    user_name = session.get("username", "Learner")
    # If already onboarded, go straight to dashboard
    try:
        user_id = session.get("user_id")
        if user_id:
            pref = prefs_table.get_item(Key={"users_id": user_id})
            if pref.get("Item"):
                return redirect(url_for("dashboard"))
    except Exception:
        pass
    return render_template("onboarding.html", username=user_name)

@app.route("/onboarding", methods=["POST"])
def onboarding_save():
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"ok": False, "error": "not_authenticated"}), 401
    data = request.get_json(silent=True) or {}
    age = data.get("age")
    country = data.get("country")
    interests = data.get("interests")
    native_language = data.get("native_language")
    target_language = data.get("target_language")
    level = data.get("level")
    
    # Â∞ÜÈÄóÂè∑ÂàÜÈöîÁöÑinterestsËΩ¨Êç¢‰∏∫interest1Âíåinterest2
    interest1 = ""
    interest2 = ""
    if interests:
        interests_list = interests.split(',')
        interest1 = interests_list[0].strip() if len(interests_list) > 0 else ""
        interest2 = interests_list[1].strip() if len(interests_list) > 1 else ""
    
    try:
        prefs_table.put_item(Item={
            "users_id": user_id,
            "age": age,
            "country": country,
            "interest1": interest1,
            "interest2": interest2,
            "native_language": native_language,
            "target_language": target_language,
            "level": level,
        })
        return jsonify({"ok": True})
    except Exception as e:
        return jsonify({"ok": False, "error": str(e)}), 500

@app.route("/dashboard")
def dashboard():
    user_name = session.get("username", "Learner")
    return render_template("dashboard.html", username=user_name)

@app.route("/api/user/preferences", methods=["GET"])
def get_user_preferences():
    """Get user preferences including interests"""
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"success": False, "error": "Not authenticated"}), 401
    
    try:
        pref = prefs_table.get_item(Key={"users_id": user_id})
        if pref.get("Item"):
            prefs = pref["Item"]
            return jsonify({
                "success": True,
                "preferences": {
                    "age": prefs.get("age", ""),
                    "country": prefs.get("country", ""),
                    "interest1": prefs.get("interest1", ""),
                    "interest2": prefs.get("interest2", ""),
                    "native_language": prefs.get("native_language", ""),
                    "target_language": prefs.get("target_language", ""),
                    "level": prefs.get("level", "")
                }
            })
        else:
            return jsonify({"success": False, "error": "Preferences not found"}), 404
    except Exception as e:
        return jsonify({"success": False, "error": str(e)}), 500

# Learning Check-in APIs
@app.route("/api/checkin", methods=["POST"])
def daily_checkin():
    """Daily learning check-in"""
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"success": False, "error": "Not authenticated"}), 401
    
    from datetime import datetime
    today = datetime.now().strftime("%Y-%m-%d")
    timestamp = datetime.now().isoformat()
    
    # Initialize user checkins if not exists
    if user_id not in learning_checkins:
        learning_checkins[user_id] = []
    
    # Check if already checked in today
    user_records = learning_checkins[user_id]
    if any(record['date'] == today for record in user_records):
        return jsonify({"success": False, "error": "Already checked in today"})
    
    # Add checkin record
    learning_checkins[user_id].append({
        "date": today,
        "timestamp": timestamp
    })
    
    return jsonify({"success": True, "date": today})

@app.route("/api/checkin/stats", methods=["GET"])
def get_checkin_stats():
    """Get learning check-in statistics"""
    user_id = session.get("user_id")
    if not user_id:
        return jsonify({"success": False, "error": "Not authenticated"}), 401
    
    from datetime import datetime, timedelta
    
    user_records = learning_checkins.get(user_id, [])
    
    # Calculate statistics
    today = datetime.now().date()
    current_month_start = today.replace(day=1)
    
    # This month checkins
    month_checkins = len([r for r in user_records 
                         if datetime.fromisoformat(r['date']).date() >= current_month_start])
    
    # Calculate current streak
    current_streak = 0
    if user_records:
        sorted_records = sorted(user_records, key=lambda x: x['date'], reverse=True)
        check_date = today
        
        for record in sorted_records:
            record_date = datetime.fromisoformat(record['date']).date()
            if record_date == check_date or record_date == check_date - timedelta(days=1):
                current_streak += 1
                check_date = record_date - timedelta(days=1)
            else:
                break
    
    # Calculate longest streak
    longest_streak = 0
    if user_records:
        sorted_records = sorted(user_records, key=lambda x: x['date'])
        current_streak_count = 1
        
        for i in range(1, len(sorted_records)):
            prev_date = datetime.fromisoformat(sorted_records[i-1]['date']).date()
            curr_date = datetime.fromisoformat(sorted_records[i]['date']).date()
            
            if (curr_date - prev_date).days == 1:
                current_streak_count += 1
            else:
                longest_streak = max(longest_streak, current_streak_count)
                current_streak_count = 1
        
        longest_streak = max(longest_streak, current_streak_count)
    
    # Check if checked in today
    today_str = today.isoformat()
    has_checked_today = any(record['date'] == today_str for record in user_records)
    
    # Get checkin dates for calendar
    checkin_dates = [r['date'] for r in user_records]
    
    return jsonify({
        "success": True,
        "stats": {
            "total_days": len(user_records),
            "current_streak": current_streak,
            "longest_streak": longest_streak,
            "this_month": month_checkins,
            "checked_today": has_checked_today
        },
        "checkin_dates": checkin_dates
    })

@app.route("/logout", methods=["POST"])
def logout():
    session.clear()
    return redirect(url_for("home"))

@app.route("/chatbot")
def chatbot_page():
    if not session.get("user_id"):
        return redirect(url_for("register_page"))
    return render_template("chatbot.html")

# Chatbot APIs (ÈõÜÊàêS3ÂíåDynamoDB)
@app.route("/api/chatbot/message", methods=["POST"])
def chatbot_message():
    """
    ÊñáÊú¨ËÅäÂ§©Êé•Âè£ - ‰øùÂ≠òÂà∞DynamoDB
    """
    try:
        # Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÁôªÂΩï
        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not authenticated"}), 401
            
        data = request.get_json(silent=True) or {}
        text = (data.get("text") or "").strip()
        if not text:
            return jsonify({"reply": "Please type something."})
        
        print(f"üí¨ Êé•Êî∂Âà∞Áî®Êà∑ {user_id} ÁöÑÊñáÊú¨Ê∂àÊÅØ: {text}")
        
        # Ëé∑ÂèñÁî®Êà∑Âêç
        username = get_username_by_user_id(user_id)
        
        # ‰øùÂ≠òÁî®Êà∑Ê∂àÊÅØÂà∞DynamoDB
        user_log_id = save_chat_message_to_dynamodb(
            users_id=user_id,
            sender=username,  # ‰ΩøÁî®ÂÆûÈôÖÁî®Êà∑Âêç
            message_content=text,
            message_type="text"
        )
        
        # ÁîüÊàêÁÆÄÊ¥ÅÁöÑÊú∫Âô®‰∫∫ÂõûÂ§ç
        chatbot_response = f"ÊàëÊî∂Âà∞‰∫Ü‰Ω†ÁöÑÊ∂àÊÅØ: \"{text}\"\n\n"
        
        # Ê†πÊçÆÁî®Êà∑ËæìÂÖ•ÁîüÊàêÊõ¥Ëá™ÁÑ∂ÁöÑÂõûÂ§ç
        text_lower = text.lower()
        if any(word in text_lower for word in ['‰Ω†Â•Ω', 'hello', 'hi', 'Âó®']):
            chatbot_response = f"‰Ω†Â•ΩÔºÅÂæàÈ´òÂÖ¥Âíå‰Ω†ËÅäÂ§©„ÄÇ‰Ω†ÊÉ≥ÁªÉ‰π†‰ªÄ‰πàÂë¢Ôºü"
        elif any(word in text_lower for word in ['Ë∞¢Ë∞¢', 'thank', 'ÊÑüË∞¢']):
            chatbot_response = f"‰∏çÁî®ÂÆ¢Ê∞îÔºÅÊàëÂæà‰πêÊÑèÂ∏ÆÂä©‰Ω†Â≠¶‰π†„ÄÇ"
        elif any(word in text_lower for word in ['ÊÄé‰πà', 'how', 'Â¶Ç‰Ωï', 'what', '‰ªÄ‰πà']):
            chatbot_response = f"ËøôÊòØ‰∏™Â•ΩÈóÆÈ¢òÔºÅÊàë‰ª¨ÂèØ‰ª•‰∏ÄËµ∑Êé¢ËÆ®‰∏Ä‰∏ã„ÄÇ‰Ω†ÊÉ≥‰∫ÜËß£Âì™‰∏™ÊñπÈù¢Âë¢Ôºü"
        elif any(word in text_lower for word in ['Â≠¶‰π†', 'learn', 'study', 'ÁªÉ‰π†']):
            chatbot_response = f"Â≠¶‰π†ÂæàÊ£íÔºÅ‰Ω†ÂèØ‰ª•Â∞ùËØïÂíåÊàëÂØπËØùÊù•ÊèêÈ´òËØ≠Ë®ÄÊäÄËÉΩ„ÄÇ"
        else:
            chatbot_response = f"ÊòéÁôΩ‰∫ÜÔºÅÁªßÁª≠ÂíåÊàëËÅäÂ§©ÂêßÔºåËøôÊ†∑ÂèØ‰ª•Â∏ÆÂä©‰Ω†ÊèêÈ´òËØ≠Ë®ÄËÉΩÂäõ„ÄÇ"
        
        print(f"ü§ñ Êú∫Âô®‰∫∫ÂõûÂ§ç: {chatbot_response}")
        
        # ‰øùÂ≠òÊú∫Âô®‰∫∫ÂõûÂ§çÂà∞DynamoDB
        bot_log_id = save_chat_message_to_dynamodb(
            users_id=user_id,
            sender="system",  # ‰ΩøÁî® "system" ËÄå‰∏çÊòØ "bot"
            message_content=chatbot_response,
            message_type="text"
        )
        
        return jsonify({"reply": chatbot_response})
        
    except Exception as e:
        print(f"‚ùå ÊñáÊú¨ËÅäÂ§©Â§ÑÁêÜÈîôËØØ: {str(e)}")
        return jsonify({"error": f"ÊúçÂä°Âô®ÈîôËØØ: {str(e)}"}), 500

@app.route("/api/chatbot/message-audio", methods=["POST"])
def chatbot_message_audio():
    """
    ÂÆåÊï¥ÁöÑËØ≠Èü≥ËÅäÂ§©Êé•Âè£ - ‰ΩøÁî®‰∏éfrontend.htmlÁõ∏ÂêåÁöÑJSONÊ†ºÂºèÂ§ÑÁêÜ
    
    Â∑•‰ΩúÊµÅÁ®ãÔºö
    1. Êé•Êî∂JSONÊ†ºÂºèÁöÑbase64Èü≥È¢ëÊï∞ÊçÆ
    2. Â∞Übase64Èü≥È¢ëËΩ¨Êç¢‰∏∫‰∏¥Êó∂Êñá‰ª∂
    3. ‰ΩøÁî®ËØ≠Èü≥ËΩ¨ÊñáÂ≠óÊúçÂä°Ëé∑ÂèñËΩ¨ÂΩïÊñáÊú¨
    4. Â§ÑÁêÜËÅäÂ§©ÈÄªËæëÁîüÊàêÂõûÂ§ç
    5. ‰øùÂ≠òÁî®Êà∑Ê∂àÊÅØÂíåÊú∫Âô®‰∫∫ÂõûÂ§çÂà∞DynamoDB
    6. ËøîÂõûÂÆåÊï¥ÁöÑËÅäÂ§©ÂìçÂ∫î
    """
    try:
        import base64
        import tempfile
        import os
        
        # Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÁôªÂΩï
        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not authenticated"}), 401
        
        # Ê≠•È™§1: Êé•Êî∂ÂíåÈ™åËØÅJSONÊï∞ÊçÆ
        json_data = request.get_json()
        if not json_data:
            return jsonify({"error": "No JSON data received"}), 400
        
        base64_audio = json_data.get('audio')
        if not base64_audio:
            return jsonify({"error": "No audio data in JSON"}), 400
        
        print(f"üì§ Êé•Êî∂Âà∞Áî®Êà∑ {user_id} ÁöÑbase64Èü≥È¢ëÊï∞ÊçÆ")
        print(f"üìä Base64Êï∞ÊçÆÈïøÂ∫¶: {len(base64_audio)}")
        
        # Ê≠•È™§2: Â∞Übase64Èü≥È¢ëËΩ¨Êç¢‰∏∫‰∏¥Êó∂Êñá‰ª∂
        try:
            audio_data = base64.b64decode(base64_audio)
            print(f"üìÅ Ëß£Á†ÅÂêéÈü≥È¢ëÂ§ßÂ∞è: {len(audio_data)} bytes")
            
            # ÂàõÂª∫‰∏¥Êó∂Êñá‰ª∂
            with tempfile.NamedTemporaryFile(delete=False, suffix='.webm') as temp_file:
                temp_file.write(audio_data)
                temp_file_path = temp_file.name
            
            print(f"üìÇ ÂàõÂª∫‰∏¥Êó∂Êñá‰ª∂: {temp_file_path}")
            
        except Exception as e:
            print(f"‚ùå Base64Ëß£Á†ÅÂ§±Ë¥•: {str(e)}")
            return jsonify({"error": f"Invalid base64 audio data: {str(e)}"}), 400
        
        # ÁîüÊàêËØ∑Ê±ÇÂîØ‰∏ÄÊ†áËØÜ
        import hashlib
        audio_hash = hashlib.md5(audio_data).hexdigest()
        request_id = f"{user_id}_{int(time.time())}_{audio_hash[:8]}"
        
        print(f" ËØ∑Ê±ÇID: {request_id}")
        
        # Ê≠•È™§3: Ëé∑ÂèñÁî®Êà∑ËØ≠Ë®ÄÂ≠¶‰π†ÂÅèÂ•Ω
        user_preferences = get_user_language_preferences(user_id)
        target_language = user_preferences.get('target_language', 'English')
        user_level = user_preferences.get('level', 'Beginner')
        
        # Ê≠•È™§4: ËØ≠Èü≥ÂèëÈü≥ËØÑ‰º∞ - ‰ΩøÁî®‰∏¥Êó∂Êñá‰ª∂Ë∑ØÂæÑ
        print(f"üéØ ÂºÄÂßãÂèëÈü≥ËØÑ‰º∞ÂàÜÊûê...")
        pronunciation_result = analyze_pronunciation_accuracy(
            audio_file=temp_file_path,  # ‰º†ÈÄí‰∏¥Êó∂Êñá‰ª∂Ë∑ØÂæÑ
            target_language=target_language,
            user_level=user_level
        )
        print(f"üìä ÂèëÈü≥ËØÑ‰º∞ÂÆåÊàê: {pronunciation_result.get('pronunciation_score', 0)}ÂàÜ")
        
        # Ê≠•È™§5: ÂàõÂª∫‰∏Ä‰∏™Á±ª‰ººÊñá‰ª∂ÂØπË±°Êù•‰∏ä‰º†Âà∞S3
        class AudioFileObj:
            def __init__(self, file_path):
                self.filename = 'recording.webm'
                self._file_path = file_path
                self._file = None
                self._position = 0
            
            def read(self, size=-1):
                """ËØªÂèñÊñá‰ª∂ÂÜÖÂÆπ"""
                if self._file is None:
                    self._file = open(self._file_path, 'rb')
                    self._file.seek(self._position)
                
                if size == -1:
                    data = self._file.read()
                else:
                    data = self._file.read(size)
                
                self._position = self._file.tell()
                return data
            
            def seek(self, position, whence=0):
                """ËÆæÁΩÆÊñá‰ª∂ÊåáÈíà‰ΩçÁΩÆ"""
                if self._file is None:
                    self._file = open(self._file_path, 'rb')
                
                self._file.seek(position, whence)
                self._position = self._file.tell()
            
            def tell(self):
                """Ëé∑ÂèñÂΩìÂâçÊñá‰ª∂ÊåáÈíà‰ΩçÁΩÆ"""
                return self._position
            
            def close(self):
                """ÂÖ≥Èó≠Êñá‰ª∂"""
                if self._file:
                    self._file.close()
                    self._file = None
        
        # ‰ΩøÁî®ÂÆûÈôÖÊñá‰ª∂ÂØπË±°‰∏ä‰º†Âà∞S3ÔºàÊõ¥ÁÆÄÂçïÁöÑÊñπÊ≥ïÔºâ
        print(f"üìÇ ÂáÜÂ§á‰∏ä‰º†Èü≥È¢ëÊñá‰ª∂Âà∞S3: {temp_file_path}")
        try:
            with open(temp_file_path, 'rb') as audio_file:
                user_audio_s3_url = upload_audio_to_s3(audio_file, user_id, is_bot_audio=False)
        except Exception as e:
            print(f"‚ùå ÊâìÂºÄ‰∏¥Êó∂Èü≥È¢ëÊñá‰ª∂Â§±Ë¥•: {e}")
            user_audio_s3_url = None
        
        # Ê≠•È™§6: ÊîπËøõËΩ¨ÂΩïÊñáÊú¨ÁöÑÂ§ÑÁêÜ
        transcript = pronunciation_result.get('transcript', '').strip()
        
        print(f"üé§ ÂéüÂßãËΩ¨ÂΩïÁªìÊûú: '{transcript}'")
        print(f"üé§ ËΩ¨ÂΩïÁªìÊûúÈïøÂ∫¶: {len(transcript)}")
        print(f"üé§ ËΩ¨ÂΩïÁªìÊûúÊòØÂê¶‰∏∫Á©∫: {not transcript}")
        
        # Ê£ÄÊü•ÊòØÂê¶ÊòØÈîôËØØ‰ø°ÊÅØ
        if (not transcript or 
            transcript.startswith('[ËØ≠Èü≥ËØÜÂà´Â§±Ë¥•]') or 
            transcript.startswith('[ÈîôËØØ]') or
            transcript.startswith('(demo)')):
            
            print("‚ö†Ô∏è ËΩ¨ÂΩïÂ§±Ë¥•ÔºåÁîüÊàêÂü∫‰∫éÂÆûÈôÖËØ≠Èü≥ÁöÑÂõûÂ§ç")
            
            # ‰∏ç‰ΩøÁî®demoÊñáÊú¨ÔºåËÄåÊòØÂü∫‰∫éÁî®Êà∑Á°ÆÂÆûÂΩïÂà∂‰∫ÜËØ≠Èü≥ÁöÑ‰∫ãÂÆûÊù•ÂõûÂ§ç
            display_transcript = "Â∑≤ÂΩïÂà∂ËØ≠Èü≥ (ËΩ¨ÂΩïÂ§ÑÁêÜ‰∏≠...)"
            
            chatbot_response = f"üé§ ÊàëÂê¨Âà∞‰∫Ü‰Ω†ÁöÑËØ≠Èü≥ÂΩïÂà∂ÔºÅ\n\n"
            chatbot_response += f"ËôΩÁÑ∂ËØ≠Èü≥ËΩ¨ÊñáÂ≠óÊúçÂä°ÊöÇÊó∂ÈÅáÂà∞‰∫Ü‰∏Ä‰∫õÊäÄÊúØÈóÆÈ¢òÔºå‰ΩÜÊàëÁü•ÈÅì‰Ω†Âú®ÁªÉ‰π†ÂèëÈü≥ÔºåËøôÂæàÊ£íÔºÅ\n\n"
            chatbot_response += f"üìä Èü≥È¢ë‰ø°ÊÅØ:\n"
            chatbot_response += f"‚Ä¢ Èü≥È¢ëÈïøÂ∫¶: {len(audio_data)} Â≠óËäÇ\n"
            chatbot_response += f"‚Ä¢ ÁõÆÊ†áËØ≠Ë®Ä: {target_language}\n"
            chatbot_response += f"‚Ä¢ ‰Ω†ÁöÑÁ∫ßÂà´: {user_level}\n\n"
            
            if pronunciation_result.get('error'):
                chatbot_response += f"‚ö†Ô∏è ÊäÄÊúØÈóÆÈ¢ò: {pronunciation_result.get('message', 'Êú™Áü•ÈîôËØØ')}\n\n"
            
            chatbot_response += f"‚úÖ ÁªßÁª≠‰øùÊåÅÁªÉ‰π†ÔºÅÊØè‰∏ÄÊ¨°ÂºÄÂè£ÈÉΩÊòØËøõÊ≠•ÔºÅ"
            
        else:
            # ÊàêÂäüËΩ¨ÂΩïÔºåÁîüÊàêÂü∫‰∫éËΩ¨ÂΩïÂÜÖÂÆπÁöÑÊô∫ËÉΩÂõûÂ§ç
            print(f"‚úÖ ËΩ¨ÂΩïÊàêÂäü: {transcript}")
            display_transcript = transcript
            
            # ÊûÑÂª∫Êô∫ËÉΩÂõûÂ§ç
            score = pronunciation_result.get('pronunciation_score', 0)
            accuracy = pronunciation_result.get('accuracy_score', 0)
            fluency = pronunciation_result.get('fluency_score', 0)
            
            chatbot_response = f"üé§ ÊàëÂê¨Âà∞‰Ω†ËØ¥: '{transcript}'\n\n"
            
            # Ê†πÊçÆËΩ¨ÂΩïÂÜÖÂÆπÁîüÊàêÊõ¥Êô∫ËÉΩÁöÑÂõûÂ§ç
            if any(word in transcript.lower() for word in ['hello', 'hi', '‰Ω†Â•Ω', 'nihao']):
                chatbot_response += f"üëã ÂæàÈ´òÂÖ¥Âê¨Âà∞‰Ω†ÁöÑÈóÆÂÄôÔºÅ‰Ω†ÁöÑÂèëÈü≥Âê¨Ëµ∑Êù•‰∏çÈîô„ÄÇ\n\n"
            elif any(word in transcript.lower() for word in ['how', 'what', 'where', '‰ªÄ‰πà', 'ÊÄé‰πà', 'Âì™Èáå']):
                chatbot_response += f"ü§î ÊàëÂê¨Âà∞‰Ω†Âú®ÈóÆÈóÆÈ¢òÔºåËøôÊòØÂ≠¶‰π†ËØ≠Ë®ÄÁöÑÂ•ΩÊñπÊ≥ïÔºÅ\n\n"
            elif any(word in transcript.lower() for word in ['thank', 'thanks', 'Ë∞¢Ë∞¢', 'xiexie']):
                chatbot_response += f"üòä ‰∏çÁî®ÂÆ¢Ê∞îÔºÅÂæàÈ´òÂÖ¥ËÉΩÂ∏ÆÂä©‰Ω†Â≠¶‰π†„ÄÇ\n\n"
            else:
                chatbot_response += f"üëç ÂæàÂ•ΩÔºÅÊàëËÉΩÁêÜËß£‰Ω†ËØ¥ÁöÑÂÜÖÂÆπ„ÄÇ\n\n"
            
            if score > 0:
                chatbot_response += f"üìä ÂèëÈü≥ËØÑ‰º∞:\n"
                chatbot_response += f"‚Ä¢ ÂèëÈü≥ÂæóÂàÜ: {score}/100\n"
                chatbot_response += f"‚Ä¢ ÂáÜÁ°ÆÂ∫¶: {accuracy}/100\n"
                chatbot_response += f"‚Ä¢ ÊµÅÂà©Â∫¶: {fluency}/100\n\n"
                
                if score >= 80:
                    chatbot_response += f"üåü ‰ºòÁßÄÔºÅ‰Ω†ÁöÑÂèëÈü≥ÂæàÊ£íÔºåÁªßÁª≠‰øùÊåÅÔºÅ"
                elif score >= 60:
                    chatbot_response += f"üëç ‰∏çÈîôÔºÅÂ§öÁªÉ‰π†‰ºöËÆ©‰Ω†ÁöÑÂèëÈü≥Êõ¥ÂÆåÁæé„ÄÇ"
                else:
                    chatbot_response += f"üí™ ÁªßÁª≠Âä™ÂäõÔºÅÊØèÂ§©ÁªÉ‰π†‰∏ÄÁÇπÔºå‰Ω†‰ºöÁúãÂà∞ËøõÊ≠•ÁöÑ„ÄÇ"
            else:
                chatbot_response += f"üéØ ÁªßÁª≠ÁªÉ‰π†ÂèëÈü≥Ôºå‰Ω†ÂÅöÂæóÂæàÂ•ΩÔºÅ"
        
        print(f"üé§ ÊúÄÁªà‰ΩøÁî®ÁöÑËΩ¨ÂΩïÁªìÊûú: {display_transcript}")
        
        # Ëé∑ÂèñÁî®Êà∑Âêç
        username = get_username_by_user_id(user_id)
        
        # Ê≠•È™§7: ‰øùÂ≠òÁî®Êà∑Ê∂àÊÅØÂà∞DynamoDB (JSONÊ†ºÂºè) - ÂåÖÂê´ÂèëÈü≥ËØÑ‰º∞ÁªìÊûú
        print(f"üíæ ÂºÄÂßã‰øùÂ≠òÁî®Êà∑Èü≥È¢ëÊ∂àÊÅØ...")
        user_log_id = save_chat_message_to_dynamodb(
            users_id=user_id,
            sender=username,  # ‰ΩøÁî®ÂÆûÈôÖÁî®Êà∑Âêç
            message_content=display_transcript,  # ‰ΩøÁî®Â§ÑÁêÜÂêéÁöÑËΩ¨ÂΩïÊñáÊú¨
            message_type="audio",
            audio_url=user_audio_s3_url,
            pronunciation_assessment=pronunciation_result  # Ê∑ªÂä†ÂèëÈü≥ËØÑ‰º∞ÁªìÊûú
        )
        
        if not user_log_id:
            print("‚ö†Ô∏è Áî®Êà∑Ê∂àÊÅØ‰øùÂ≠òÂà∞DynamoDBÂ§±Ë¥•")
            # ‰∏çËøîÂõûÈîôËØØÔºåÁªßÁª≠Â§ÑÁêÜ
        else:
            print(f"‚úÖ Áî®Êà∑Èü≥È¢ëÊ∂àÊÅØ‰øùÂ≠òÊàêÂäüÔºåID: {user_log_id}")
        
        # Ê≠•È™§8: ‰ΩøÁî®Â∑≤ÁªèÂ§ÑÁêÜÂ•ΩÁöÑËÅäÂ§©ÂõûÂ§çÔºå‰∏çÂÜçÈáçÊñ∞ÁîüÊàê
        # chatbot_response Â∑≤ÁªèÂú®Ê≠•È™§6‰∏≠Ê†πÊçÆËΩ¨ÂΩïÊàêÂäü‰∏éÂê¶ÁîüÊàê‰∫ÜÂêàÈÄÇÁöÑÂõûÂ§ç
        
        # Â¶ÇÊûúÈúÄË¶ÅÊ∑ªÂä†È¢ùÂ§ñÁöÑË∞ÉËØï‰ø°ÊÅØ(ÂèØÈÄâ)
        if pronunciation_result.get('error'):
            # Âú®ÂéüÊúâÂõûÂ§çÂü∫Á°Ä‰∏äÊ∑ªÂä†ÊäÄÊúØ‰ø°ÊÅØ
            chatbot_response += f"\n\nÔøΩ **ÊäÄÊúØ‰ø°ÊÅØ:**\n"
            chatbot_response += f"‚Ä¢ ËØ∑Ê±ÇID: {request_id}\n"
            chatbot_response += f"‚Ä¢ ÈîôËØØËØ¶ÊÉÖ: {pronunciation_result.get('message', 'Êú™Áü•ÈîôËØØ')}\n"
        
        # Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
        try:
            os.unlink(temp_file_path)
            print(f"üóëÔ∏è Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂: {temp_file_path}")
        except Exception as e:
            print(f"‚ö†Ô∏è Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂Â§±Ë¥•: {str(e)}")
        
        # Ê≠•È™§9: ‰øùÂ≠òÊú∫Âô®‰∫∫ÂõûÂ§çÂà∞DynamoDB
        print(f"ü§ñ ÂºÄÂßã‰øùÂ≠òÊú∫Âô®‰∫∫ÂõûÂ§ç...")
        bot_log_id = save_chat_message_to_dynamodb(
            users_id=user_id,
            sender="system",  # Êú∫Âô®‰∫∫Ê∂àÊÅØ‰ΩøÁî®'system'‰Ωú‰∏∫ÂèëÈÄÅËÄÖ
            message_content=chatbot_response,
            message_type="text",
            audio_url=None,  # Êú∫Âô®‰∫∫ÂõûÂ§çÈÄöÂ∏∏ÊòØÊñáÊú¨
            pronunciation_assessment=None  # Êú∫Âô®‰∫∫ÂõûÂ§ç‰∏çÈúÄË¶ÅÂèëÈü≥ËØÑ‰º∞
        )
        
        if not bot_log_id:
            print("‚ö†Ô∏è Êú∫Âô®‰∫∫ÂõûÂ§ç‰øùÂ≠òÂà∞DynamoDBÂ§±Ë¥•")
        else:
            print(f"‚úÖ Êú∫Âô®‰∫∫ÂõûÂ§ç‰øùÂ≠òÊàêÂäüÔºåID: {bot_log_id}")
        
        # ÊâìÂç∞ÂÆåÊï¥ÁöÑËÅäÂ§©‰ºöËØù‰øùÂ≠òÁä∂ÊÄÅ
        print(f"üìä ËÅäÂ§©‰ºöËØù‰øùÂ≠òÁä∂ÊÄÅ:")
        print(f"   üë§ Áî®Êà∑Ê∂àÊÅØID: {user_log_id}")
        print(f"   ü§ñ Êú∫Âô®‰∫∫ÂõûÂ§çID: {bot_log_id}")
        print(f"   üíæ ‰ºöËØùÂÆåÊï¥ÊÄß: {'‚úÖ ÂÆåÊï¥' if user_log_id and bot_log_id else '‚ö†Ô∏è ‰∏çÂÆåÊï¥'}")
        
        # Â§ÑÁêÜÂçïËØçÁ∫ßÂà´ÁöÑÂàÜÊûêÁªìÊûúÔºå‰∏∫ÂâçÁ´ØÊèê‰æõÈ¢úËâ≤Ê†áÊ≥®‰ø°ÊÅØ
        words_analysis = pronunciation_result.get('words_analysis', [])
        
        # ÂàõÂª∫ÂçïËØçÈ¢úËâ≤Êò†Â∞ÑÂáΩÊï∞
        def get_word_color_class(word_data):
            """Ê†πÊçÆÂçïËØçÁöÑÈîôËØØÁ±ªÂûãÂíåÂáÜÁ°ÆÂ∫¶ËøîÂõûCSSÁ±ªÂêç"""
            if not isinstance(word_data, dict):
                return 'word-normal'
                
            error_type = word_data.get('errorType', '').strip()
            error_type_en = word_data.get('errorTypeEn', '').strip()
            accuracy_score = word_data.get('accuracyScore', 0)
            
            print(f"üîç Â§ÑÁêÜÂçïËØç: '{word_data.get('word', '')}', ÈîôËØØÁ±ªÂûã: '{error_type}', Ëã±ÊñáÁ±ªÂûã: '{error_type_en}', ÂáÜÁ°ÆÂ∫¶: {accuracy_score}")
            
            # Â¶ÇÊûúÊòØÈÅóÊºèÔºàOmissionÔºâÔºå‰∏ç‰∏äËâ≤
            if error_type_en == 'Omission' or error_type == 'ÈÅóÊºè':
                print(f"  -> ÈÅóÊºèÂçïËØçÔºå‰∏ç‰∏äËâ≤")
                return 'word-omission'  # ÁâπÊÆäÁ±ªÔºå‰∏çÊòæÁ§∫È¢úËâ≤
            
            # Â¶ÇÊûúÊòØÊ≠£Á°ÆÁöÑÂçïËØçÔºåÊ†πÊçÆÂáÜÁ°ÆÂ∫¶ÂàÜÊï∞ÁªôÈ¢úËâ≤
            if error_type_en == 'None' or error_type == 'Ê≠£Á°Æ':
                if accuracy_score >= 90:
                    print(f"  -> ‰ºòÁßÄ (ÁªøËâ≤)")
                    return 'word-excellent'     # ÁªøËâ≤ - ‰ºòÁßÄ
                elif accuracy_score >= 80:
                    print(f"  -> ËâØÂ•Ω (ËìùËâ≤)")
                    return 'word-good'          # ËìùËâ≤ - ËâØÂ•Ω  
                elif accuracy_score >= 70:
                    print(f"  -> ‰∏ÄËà¨ (ÈªÑËâ≤)")
                    return 'word-fair'          # ÈªÑËâ≤ - ‰∏ÄËà¨
                elif accuracy_score > 0:
                    print(f"  -> ÈúÄË¶ÅÊîπËøõ (Ê©ôËâ≤)")
                    return 'word-poor'          # Ê©ôËâ≤ - ÈúÄË¶ÅÊîπËøõ
                else:
                    print(f"  -> Ê≠£Â∏∏È¢úËâ≤")
                    return 'word-normal'        # Ê≠£Â∏∏È¢úËâ≤
            else:
                # ÂÖ∂‰ªñÈîôËØØÁ±ªÂûãÔºåÊ†πÊçÆÂáÜÁ°ÆÂ∫¶ÁªôÈ¢úËâ≤
                if accuracy_score >= 70:
                    print(f"  -> ÈîôËØØ‰ΩÜÂàÜÊï∞È´ò (ÈªÑËâ≤)")
                    return 'word-fair'          # ÈªÑËâ≤
                else:
                    print(f"  -> ÈîôËØØÂàÜÊï∞‰Ωé (Á∫¢Ëâ≤)")
                    return 'word-poor'          # Á∫¢Ëâ≤
        
        
        # Â§ÑÁêÜÂçïËØçÂàÜÊûêÁªìÊûú
        formatted_words = []
        if isinstance(words_analysis, list):
            for word_info in words_analysis:
                if isinstance(word_info, dict):
                    formatted_word = {
                        'word': word_info.get('word', ''),
                        'index': word_info.get('index', 0),
                        'errorType': word_info.get('errorType', ''),
                        'errorTypeEn': word_info.get('errorTypeEn', ''),
                        'accuracyScore': word_info.get('accuracyScore', 0),
                        'colorClass': get_word_color_class(word_info)
                    }
                    formatted_words.append(formatted_word)
        
        # ËøîÂõûÂìçÂ∫î
        return jsonify({
            "reply": chatbot_response,
            "transcript": display_transcript,  # ‰ΩøÁî®Â§ÑÁêÜÂêéÁöÑËΩ¨ÂΩïÊñáÊú¨
            "pronunciation_score": pronunciation_result.get('pronunciation_score', 0),
            "accuracy_score": pronunciation_result.get('accuracy_score', 0),
            "fluency_score": pronunciation_result.get('fluency_score', 0),
            "words_analysis": formatted_words,  # Ê∑ªÂä†Ê†ºÂºèÂåñÂêéÁöÑÂçïËØçÂàÜÊûê
            "reference_text": pronunciation_result.get('reference_text', ''),  # ÂèÇËÄÉÊñáÊú¨
            "recognized_text": pronunciation_result.get('transcript', display_transcript),  # ËØÜÂà´ÊñáÊú¨
            "user_audio_url": user_audio_s3_url,  # Ê∑ªÂä†S3Èü≥È¢ëURL
            "tts_url": None  # TTS URLÔºàÂ¶ÇÊûúÊúâÁöÑËØùÔºâ
        })
        
    except Exception as e:
        print(f"‚ùå ËØ≠Èü≥ËÅäÂ§©Â§ÑÁêÜÈîôËØØ: {str(e)}")
        
        # Á°Æ‰øùÊ∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂
        if 'temp_file_path' in locals():
            try:
                os.unlink(temp_file_path)
                print(f"üóëÔ∏è ÂºÇÂ∏∏Ê∏ÖÁêÜ‰∏¥Êó∂Êñá‰ª∂: {temp_file_path}")
            except:
                pass
        
        return jsonify({"error": f"ÊúçÂä°Âô®ÈîôËØØ: {str(e)}"}), 500

@app.route("/api/chatbot/history", methods=["GET"])
def chatbot_history():
    """
    Ëé∑ÂèñÁî®Êà∑ËÅäÂ§©ÂéÜÂè≤ËÆ∞ÂΩïAPI
    
    ÊîØÊåÅÂàÜÈ°µÊü•ËØ¢ÔºåËøîÂõûÁî®Êà∑ÁöÑÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩïÔºåÂåÖÊã¨ÊñáÊú¨ÂíåÈü≥È¢ëÊ∂àÊÅØ
    
    URLÂèÇÊï∞:
    - limit: ÊØèÈ°µËøîÂõûÁöÑÊ∂àÊÅØÊï∞Èáè (ÈªòËÆ§20)
    - last_chatbot_logs_id: ‰∏äÊ¨°Êü•ËØ¢ÁöÑÊúÄÂêé‰∏Ä‰∏™ËÆ∞ÂΩïIDÔºåÁî®‰∫éÂàÜÈ°µ
    """
    try:
        # Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÁôªÂΩï
        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not authenticated"}), 401
        
        # Ëé∑ÂèñÊü•ËØ¢ÂèÇÊï∞
        limit = int(request.args.get('limit', 20))
        last_chatbot_logs_id = request.args.get('last_chatbot_logs_id')
        
        print(f"üìú Ëé∑ÂèñÁî®Êà∑ {user_id} ÁöÑËÅäÂ§©ÂéÜÂè≤ÔºåÈôêÂà∂: {limit}")
        
        # ‰ªéDynamoDBËé∑ÂèñËÅäÂ§©ÂéÜÂè≤
        history_data = get_chat_history_from_dynamodb(user_id, limit, last_chatbot_logs_id)
        
        if not history_data['messages']:
            return jsonify({
                "success": True,
                "messages": [],
                "has_more": False,
                "message": "No chat history found"
            })
        
        # Ê†ºÂºèÂåñËøîÂõûÊï∞ÊçÆ
        formatted_messages = []
        for msg in history_data['messages']:
            formatted_msg = {
                "chatbot_logs_id": msg['chatbot_logs_id'],
                "sender": msg['sender'],
                "message": msg['message_content'],
                "message_type": msg['message_type'],
                "timestamp": msg['timestamp']
            }
            
            # Â¶ÇÊûúÊúâÈü≥È¢ëÊñá‰ª∂ÔºåÊ∑ªÂä†Èü≥È¢ëURL
            if 'audio_url' in msg:
                formatted_msg['audio_url'] = msg['audio_url']
            
            formatted_messages.append(formatted_msg)
        
        print(f"‚úÖ ËÅäÂ§©ÂéÜÂè≤Ëé∑ÂèñÊàêÂäü: {len(formatted_messages)} Êù°Ê∂àÊÅØ")
        
        return jsonify({
            "success": True,
            "messages": formatted_messages,
            "has_more": history_data['has_more'],
            "last_chatbot_logs_id": history_data['last_chatbot_logs_id']
        })
        
    except Exception as e:
        print(f"‚ùå Ëé∑ÂèñËÅäÂ§©ÂéÜÂè≤ÈîôËØØ: {str(e)}")
        return jsonify({
            "error": f"Failed to get chat history: {str(e)}",
            "success": False
        }), 500

# ===== Ë∞ÉËØïÂíåÈ™åËØÅ API =====

@app.route("/api/debug/test-connections", methods=["GET"])
def test_connections():
    """
    ÊµãËØï AWS S3 Âíå DynamoDB ËøûÊé•
    """
    results = {
        "s3_connection": False,
        "dynamodb_users_table": False,
        "dynamodb_chatbot_logs_table": False,
        "errors": []
    }
    
    # ÊµãËØï S3 ËøûÊé•
    try:
        s3_client.list_objects_v2(Bucket=S3_BUCKET_NAME, MaxKeys=1)
        results["s3_connection"] = True
        print(f"‚úÖ S3 ËøûÊé•ÊàêÂäü: {S3_BUCKET_NAME}")
    except Exception as e:
        error_msg = f"S3 ËøûÊé•Â§±Ë¥•: {str(e)}"
        results["errors"].append(error_msg)
        print(f"‚ùå {error_msg}")
    
    # ÊµãËØï Users Ë°®ËøûÊé•
    try:
        users_table.table_status
        results["dynamodb_users_table"] = True
        print(f"‚úÖ Users Ë°®ËøûÊé•ÊàêÂäü: {DYNAMODB_TABLE}")
    except Exception as e:
        error_msg = f"Users Ë°®ËøûÊé•Â§±Ë¥•: {str(e)}"
        results["errors"].append(error_msg)
        print(f"‚ùå {error_msg}")
    
    # ÊµãËØï Chatbot Logs Ë°®ËøûÊé•
    try:
        chatbot_logs_table.table_status
        results["dynamodb_chatbot_logs_table"] = True
        print(f"‚úÖ Chatbot Logs Ë°®ËøûÊé•ÊàêÂäü: {CHATBOT_LOGS_TABLE}")
    except Exception as e:
        error_msg = f"Chatbot Logs Ë°®ËøûÊé•Â§±Ë¥•: {str(e)}"
        results["errors"].append(error_msg)
        print(f"‚ùå {error_msg}")
        
        # Â¶ÇÊûúË°®‰∏çÂ≠òÂú®ÔºåÊèê‰æõÂàõÂª∫Ë°®ÁöÑ‰ø°ÊÅØ
        if "ResourceNotFoundException" in str(e):
            results["chatbot_logs_table_missing"] = True
            results["create_table_info"] = {
                "message": "ÈúÄË¶ÅÂàõÂª∫ chat_logs Ë°®",
                "table_name": CHATBOT_LOGS_TABLE,
                "partition_key": "users_id",
                "sort_key": "chatbot_logs_id"
            }
    
    return jsonify(results)

@app.route("/api/debug/view-chatbot-logs", methods=["GET"])
def view_all_chatbot_logs():
    """
    Êü•ÁúãÊâÄÊúâÁî®Êà∑ÁöÑËÅäÂ§©ËÆ∞ÂΩï (Ë∞ÉËØïÁî®) - ÊòæÁ§∫ÂéüÂßãÊï∞ÊçÆÊ†ºÂºè
    """
    try:
        # Êâ´ÊèèÊï¥‰∏™ chatbot_logs Ë°® (‰ªÖÁî®‰∫éË∞ÉËØïÔºåÁîü‰∫ßÁéØÂ¢É‰∏çÊé®Ëçê)
        response = chatbot_logs_table.scan()
        
        items = response.get('Items', [])
        
        # ‰∏çÊ†ºÂºèÂåñÔºåÁõ¥Êé•ËøîÂõûÂéüÂßãÊï∞ÊçÆ‰ª•‰æøÊü•ÁúãÂ≠òÂÇ®Ê†ºÂºè
        print(f"üîç Êü•ÁúãÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩï: ÂÖ± {len(items)} Êù°")
        
        return jsonify({
            'success': True,
            'total_records': len(items),
            'raw_data': items,  # ËøîÂõûÂéüÂßãÊï∞ÊçÆ
            'note': 'ËøôÊòØÂéüÂßãDynamoDBÊï∞ÊçÆÔºåmessageÂ≠óÊÆµÁé∞Âú®ÊòØJSONÂØπË±°ËÄå‰∏çÊòØÂ≠óÁ¨¶‰∏≤'
        })
        
    except Exception as e:
        error_msg = f"Êü•ÁúãËÅäÂ§©ËÆ∞ÂΩïÂ§±Ë¥•: {str(e)}"
        print(f"‚ùå {error_msg}")
        return jsonify({
            'success': False,
            'error': error_msg
        }), 500

@app.route("/api/debug/view-my-chatbot-logs", methods=["GET"])
def view_my_chatbot_logs():
    """
    Êü•ÁúãÂΩìÂâçÁôªÂΩïÁî®Êà∑ÁöÑËÅäÂ§©ËÆ∞ÂΩï
    """
    try:
        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not authenticated"}), 401
        
        # Ëé∑ÂèñÁî®Êà∑ÁöÑËÅäÂ§©ÂéÜÂè≤
        history_data = get_chat_history_from_dynamodb(user_id, limit=50)
        
        print(f"üîç Êü•ÁúãÁî®Êà∑ {user_id} ÁöÑËÅäÂ§©ËÆ∞ÂΩï: ÂÖ± {len(history_data['messages'])} Êù°")
        
        return jsonify({
            'success': True,
            'user_id': user_id,
            'total_records': len(history_data['messages']),
            'logs': history_data['messages']
        })
        
    except Exception as e:
        error_msg = f"Êü•ÁúãÁî®Êà∑ËÅäÂ§©ËÆ∞ÂΩïÂ§±Ë¥•: {str(e)}"
        print(f"‚ùå {error_msg}")
        return jsonify({
            'success': False,
            'error': error_msg
        }), 500

@app.route("/api/debug/test-s3-files", methods=["GET"])
def test_s3_files():
    """
    ÊµãËØï S3 Â≠òÂÇ®Ê°∂‰∏≠ÁöÑÈü≥È¢ëÊñá‰ª∂
    """
    try:
        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not authenticated"}), 401
        
        # ÂàóÂá∫Áî®Êà∑ÁöÑÈü≥È¢ëÊñá‰ª∂
        prefix = f"audio/user/{user_id}/"
        response = s3_client.list_objects_v2(
            Bucket=S3_BUCKET_NAME,
            Prefix=prefix,
            MaxKeys=10  # Âè™ÊòæÁ§∫ÊúÄËøëÁöÑ10‰∏™Êñá‰ª∂
        )
        
        files = []
        if 'Contents' in response:
            for obj in response['Contents']:
                file_info = {
                    'key': obj['Key'],
                    'size': obj['Size'],
                    'last_modified': obj['LastModified'].isoformat(),
                    'url': f"https://{S3_BUCKET_NAME}.s3.{os.environ.get('AWS_REGION', 'ap-southeast-1')}.amazonaws.com/{obj['Key']}"
                }
                files.append(file_info)
        
        # ‰πüÊ£ÄÊü•Êú∫Âô®‰∫∫Èü≥È¢ëÊñá‰ª∂
        bot_prefix = f"audio/bot/{user_id}/"
        bot_response = s3_client.list_objects_v2(
            Bucket=S3_BUCKET_NAME,
            Prefix=bot_prefix,
            MaxKeys=10
        )
        
        bot_files = []
        if 'Contents' in bot_response:
            for obj in bot_response['Contents']:
                file_info = {
                    'key': obj['Key'],
                    'size': obj['Size'],
                    'last_modified': obj['LastModified'].isoformat(),
                    'url': f"https://{S3_BUCKET_NAME}.s3.{os.environ.get('AWS_REGION', 'ap-southeast-1')}.amazonaws.com/{obj['Key']}"
                }
                bot_files.append(file_info)
        
        return jsonify({
            'success': True,
            'user_id': user_id,
            'bucket': S3_BUCKET_NAME,
            'user_audio_files': files,
            'bot_audio_files': bot_files,
            'total_user_files': len(files),
            'total_bot_files': len(bot_files)
        })
        
    except Exception as e:
        error_msg = f"Ê£ÄÊü• S3 Êñá‰ª∂Â§±Ë¥•: {str(e)}"
        print(f"‚ùå {error_msg}")
        return jsonify({
            'success': False,
            'error': error_msg
        }), 500

@app.route("/api/debug/download-s3-file", methods=["GET"])
def download_s3_file():
    """
    ÁîüÊàê S3 Êñá‰ª∂ÁöÑÈ¢ÑÁ≠æÂêç‰∏ãËΩΩÈìæÊé•
    """
    try:
        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not authenticated"}), 401
        
        s3_key = request.args.get('key')
        if not s3_key:
            return jsonify({"error": "Missing 'key' parameter"}), 400
        
        # È™åËØÅÁî®Êà∑Âè™ËÉΩËÆøÈóÆËá™Â∑±ÁöÑÊñá‰ª∂
        if not (s3_key.startswith(f"audio/user/{user_id}/") or s3_key.startswith(f"audio/bot/{user_id}/")):
            return jsonify({"error": "Access denied"}), 403
        
        # ÁîüÊàêÈ¢ÑÁ≠æÂêç URLÔºàÊúâÊïàÊúü1Â∞èÊó∂Ôºâ
        presigned_url = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': S3_BUCKET_NAME, 'Key': s3_key},
            ExpiresIn=3600  # 1Â∞èÊó∂
        )
        
        return jsonify({
            'success': True,
            'key': s3_key,
            'presigned_url': presigned_url,
            'expires_in': 3600
        })
        
    except Exception as e:
        error_msg = f"ÁîüÊàê‰∏ãËΩΩÈìæÊé•Â§±Ë¥•: {str(e)}"
        print(f"‚ùå {error_msg}")
        return jsonify({
            'success': False,
            'error': error_msg
        }), 500


# ===== Áî®Êà∑ÁÆ°ÁêÜ API =====

@app.route("/api/user/profile", methods=["GET"])
def get_user_profile():
    """
    Ëé∑ÂèñÂΩìÂâçÁôªÂΩïÁî®Êà∑ÁöÑ‰∏™‰∫∫ËµÑÊñôÂíåÂÅèÂ•ΩËÆæÁΩÆ
    
    ËøîÂõû:
    - ÂΩìÂâçÁî®Êà∑ÁöÑÂü∫Êú¨‰ø°ÊÅØÂíåÂÅèÂ•ΩËÆæÁΩÆ
    """
    try:
        # Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÁôªÂΩï
        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not authenticated"}), 401
        
        # Ëé∑ÂèñÁî®Êà∑Âü∫Êú¨‰ø°ÊÅØ
        user_response = users_table.get_item(Key={'id': user_id})
        if 'Item' not in user_response:
            return jsonify({"error": "User not found"}), 404
            
        user_info = user_response['Item']
        
        # Ëé∑ÂèñÁî®Êà∑ÂÅèÂ•ΩËÆæÁΩÆ
        prefs_response = prefs_table.get_item(Key={'users_id': user_id})
        user_preferences = {}
        
        if 'Item' in prefs_response:
            prefs_item = prefs_response['Item']
            user_preferences = {
                'target_language': prefs_item.get('target_language', ''),
                'native_language': prefs_item.get('native_language', ''),
                'level': prefs_item.get('level', ''),
                'age': prefs_item.get('age', ''),
                'country': prefs_item.get('country', ''),
                'interest1': prefs_item.get('interest1', ''),
                'interest2': prefs_item.get('interest2', '')
            }
        
        # ÊûÑÂª∫ËøîÂõûÊï∞ÊçÆ
        profile_data = {
            'success': True,
            'user': {
                'id': user_info['id'],
                'username': user_info['username'],
                'email': user_info['email'],
                'preferences': user_preferences
            }
        }
        
        print(f"‚úÖ Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÊàêÂäü: Áî®Êà∑{user_id}")
        return jsonify(profile_data)
        
    except Exception as e:
        error_msg = f"Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÂ§±Ë¥•: {str(e)}"
        print(f"‚ùå {error_msg}")
        return jsonify({
            'success': False,
            'error': error_msg
        }), 500

@app.route("/api/user/preferences", methods=["POST"])
def update_user_preferences():
    """
    Êõ¥Êñ∞ÂΩìÂâçÁôªÂΩïÁî®Êà∑ÁöÑÂÅèÂ•ΩËÆæÁΩÆ
    
    ËØ∑Ê±Ç‰Ωì:
    {
        "target_language": "ÁõÆÊ†áËØ≠Ë®Ä",
        "native_language": "ÊØçËØ≠",
        "level": "Ê∞¥Âπ≥",
        "age": "Âπ¥ÈæÑ",
        "country": "ÂõΩÂÆ∂",
        "interest1": "ÂÖ¥Ë∂£1",
        "interest2": "ÂÖ¥Ë∂£2"
    }
    """
    try:
        # Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â∑≤ÁôªÂΩï
        user_id = session.get("user_id")
        if not user_id:
            return jsonify({"error": "User not authenticated"}), 401
        
        data = request.get_json()
        if not data:
            return jsonify({"error": "No data provided"}), 400
        
        # ÊûÑÂª∫Êõ¥Êñ∞ÁöÑÂÅèÂ•ΩÊï∞ÊçÆ
        preferences_data = {
            'users_id': user_id,
            'target_language': data.get('target_language', ''),
            'native_language': data.get('native_language', ''),
            'level': data.get('level', ''),
            'age': data.get('age', ''),
            'country': data.get('country', ''),
            'interest1': data.get('interest1', ''),
            'interest2': data.get('interest2', '')
        }
        
        # Êõ¥Êñ∞Áî®Êà∑ÂÅèÂ•ΩÂà∞DynamoDB
        prefs_table.put_item(Item=preferences_data)
        
        print(f"‚úÖ Áî®Êà∑ÂÅèÂ•ΩÊõ¥Êñ∞ÊàêÂäü: Áî®Êà∑{user_id}")
        return jsonify({
            "success": True,
            "message": "ÂÅèÂ•ΩËÆæÁΩÆÊõ¥Êñ∞ÊàêÂäü",
            "preferences": {k: v for k, v in preferences_data.items() if k != 'users_id'}
        })
        
    except Exception as e:
        error_msg = f"Êõ¥Êñ∞Áî®Êà∑ÂÅèÂ•ΩÂ§±Ë¥•: {str(e)}"
        print(f"‚ùå {error_msg}")
        return jsonify({
            'success': False,
            'error': error_msg
        }), 500
    
@app.route('/visionlingo')
def visionlingo():
    return render_template('visionlingo.html')

@app.route('/video_feed')
def video_feed():
    """Stream video with object detection overlay"""
    return Response(gen_frames(), 
                   mimetype='multipart/x-mixed-replace; boundary=frame')

@app.route('/select_object', methods=['POST'])
def select_object():
    global selected_object_idx
    data = request.get_json()
    selected_object_idx = data.get('index')
    return jsonify({'success': True})

@app.route('/switch_camera', methods=['POST'])
def switch_camera():
    data = request.get_json()
    camera_type = data.get('type')
    
    if camera_type == 'laptop':
        success = camera_manager.switch_to_laptop()
    elif camera_type == 'phone':
        success = camera_manager.switch_to_phone()
    
    return jsonify({'success': success, 'status': camera_manager.get_status()})

@app.route('/upload_photo', methods=['POST'])
def upload_photo():
    """Handle photo upload and switch to photo mode"""
    try:
        if 'photo' not in request.files:
            return jsonify({'success': False, 'error': 'No photo uploaded'})
        
        file = request.files['photo']
        if file.filename == '':
            return jsonify({'success': False, 'error': 'No photo selected'})
        
        # Read image directly from upload
        image_data = file.read()
        nparr = np.frombuffer(image_data, np.uint8)
        frame = cv2.imdecode(nparr, cv2.IMREAD_COLOR)
        
        if frame is None:
            return jsonify({'success': False, 'error': 'Invalid image format'})
        
        # Switch camera manager to photo mode
        camera_manager.switch_to_photo(frame)
        
        # Save uploaded file (optional)
        filename = secure_filename(file.filename)
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        
        # Save original file
        with open(filepath, 'wb') as f:
            f.write(image_data)
        
        print(f"üñºÔ∏è Photo uploaded: {filename}")
        return jsonify({'success': True, 'filename': filename})
        
    except Exception as e:
        print(f"‚ùå Photo upload error: {e}")
        return jsonify({'success': False, 'error': str(e)})
    
@app.route('/log_selection', methods=['POST'])
def log_selection():
    """Log selected object and get learning content from n8n webhook"""
    try:
        data = request.get_json()
        english_name = data.get('en', '')
        chinese_name = data.get('cn', '')
        
        if not english_name or not chinese_name:
            return jsonify({
                'status': 'error', 
                'message': 'Missing English or Chinese name'
            })
        
        # Create selection data
        selection_data = {
            "cn": chinese_name,
            "en": english_name
        }
        
        # Send to n8n webhook for learning content
        webhook_url = "https://n8n.smart87.me/webhook/related-item"
        try:
            response = requests.post(
                webhook_url,
                json=selection_data,
                headers={'Content-Type': 'application/json'},
                timeout=15
            )
            
            print(f"üîç n8n webhook status: {response.status_code}")
            print(f"üîç n8n webhook response: {response.text}")
            
            if response.status_code == 200:
                webhook_data = response.json()
                print(f"üîç Parsed n8n data: {webhook_data}")
                
                # ‚úÖ FIX: Handle your n8n response format - it's an array!
                if isinstance(webhook_data, list) and len(webhook_data) > 0:
                    response_data = webhook_data[0]  # Get first item from array
                    
                    return jsonify({
                        'status': 'success',
                        'data': selection_data,
                        'related_items': response_data.get('related_items', []),
                        'example_sentences': response_data.get('example_sentences', [])
                    })
                else:
                    # Handle case where response is not an array or is empty
                    return jsonify({
                        'status': 'success',
                        'data': selection_data,
                        'related_items': [],
                        'example_sentences': []
                    })
            else:
                print(f"‚ùå n8n webhook failed with status: {response.status_code}")
                return jsonify({
                    'status': 'success',
                    'data': selection_data,
                    'related_items': [],
                    'example_sentences': []
                })
                
        except Exception as webhook_error:
            print(f"‚ùå Webhook error: {webhook_error}")
            return jsonify({
                'status': 'success',
                'data': selection_data,
                'related_items': [],
                'example_sentences': []
            })
        
    except Exception as e:
        print(f"‚ùå log_selection error: {e}")
        return jsonify({'status': 'error', 'message': str(e)})
    
@app.route('/get_detections')
def get_detections():
    """Get current object detections"""
    global current_detections
    return jsonify({
        'detections': current_detections,
        'camera_status': camera_manager.get_status()
    })

@app.route('/clear_selection', methods=['POST'])
def clear_selection():
    global selected_object_idx
    selected_object_idx = None
    print("üîÑ Selection cleared")
    return jsonify({'status': 'cleared'})
    
@app.route('/webcam')
def webcam_section():
    """VisionLingo main page"""
    if not session.get("user_id"):
        return redirect(url_for("register_page"))
    return render_template('partial/webcam_section.html')

if __name__ == "__main__":
    print("üöÄ ÂêØÂä® Flask Â∫îÁî®...")
    print(f"üìä DynamoDB Ë°®: {CHATBOT_LOGS_TABLE}")
    print(f"üóÑÔ∏è  S3 Â≠òÂÇ®Ê°∂: {S3_BUCKET_NAME}")
    print("üîß Ë∞ÉËØïÁ´ØÁÇπ:")
    print("   - GET /api/debug/test-connections (ÊµãËØï AWS ËøûÊé•)")
    print("   - GET /api/debug/view-chatbot-logs (Êü•ÁúãÊâÄÊúâËÅäÂ§©ËÆ∞ÂΩïÂéüÂßãÊï∞ÊçÆ)")
    print("   - GET /api/debug/view-my-chatbot-logs (Êü•ÁúãÊàëÁöÑËÅäÂ§©ËÆ∞ÂΩï)")
    print("   - GET /api/debug/test-s3-files (Êü•ÁúãÊàëÁöÑ S3 Èü≥È¢ëÊñá‰ª∂)")
    print("   - GET /api/debug/download-s3-file?key=<s3_key> (‰∏ãËΩΩ S3 Êñá‰ª∂)")
    print("üîß Áî®Êà∑ÁÆ°ÁêÜÁ´ØÁÇπ:")
    print("   - GET /api/user/profile (Ëé∑ÂèñÂΩìÂâçÁî®Êà∑ËµÑÊñôÂíåÂÅèÂ•Ω)")
    print("   - POST /api/user/preferences (Êõ¥Êñ∞ÂΩìÂâçÁî®Êà∑ÂÅèÂ•Ω)")
    app.run(debug=True)